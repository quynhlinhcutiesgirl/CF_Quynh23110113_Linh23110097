# -*- coding: utf-8 -*-
"""Nháp 2 chiến lược .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1brXFCUNHvWBCdwlUlHf3cm8miBa64zCf
"""

import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import warnings

!pip install ta
import ta

from datetime import date

# Tắt cảnh báo về Chained Assignment trong Pandas (đặc biệt khi xử lý DataFrame.copy())
# warnings.filterwarnings('ignore', category=pd.core.common.SettingWithCopyWarning) # This line caused the AttributeError
warnings.filterwarnings('ignore', category=FutureWarning) # Tắt cảnh báo lỗi thời của Pandas
plt.style.use('ggplot')

# =========================================================================
# === PHẦN 1: TẢI VÀ LÀM SẠCH DỮ LIỆU (DATA ACQUISITION & CLEANING) ===
# =========================================================================

def clean_financial_data(df: pd.DataFrame, ticker_symbol: str) -> pd.DataFrame:
    """Xử lý dữ liệu tài chính thô, bao gồm xử lý NaN, lỗi OHLC, và ngoại lai."""
    if df.empty:
        print("[CLEANING] DataFrame rỗng, bỏ qua quá trình làm sạch.")
        return pd.DataFrame()

    df = df.copy()
    price_cols = ['Open', 'High', 'Low', 'Adj Close', 'Volume']

    # 1. Xử lý MultiIndex và đảm bảo 'Adj Close'
    if isinstance(df.columns, pd.MultiIndex):
        df.columns = df.columns.get_level_values(0)
    if 'Close' in df.columns and 'Adj Close' not in df.columns:
        df = df.rename(columns={'Close': 'Adj Close'})

    # Kiểm tra thiếu cột
    missing_cols = [col for col in price_cols if col not in df.columns]
    if missing_cols:
        print(f"[CLEANING ERROR] Các cột cần thiết bị thiếu: {missing_cols}. Không thể làm sạch.")
        return pd.DataFrame()

    # 2. Sắp xếp và xử lý NaN (ffill/bfill)
    df.index = pd.to_datetime(df.index)
    df = df.sort_index()
    df[price_cols] = df[price_cols].ffill().bfill()
    df.dropna(subset=['Adj Close'], inplace=True)

    # 3. Xử lý Volume = 0
    df = df[df['Volume'] > 0]

    # 4. Xử lý Lỗi OHLC (Tối giản)
    invalid_ohlc = df[
        (df['Low'] > df['High']) | (df['Adj Close'] > df['High']) |
        (df['Adj Close'] < df['Low']) | (df['Open'] < df['Low']) |
        (df['Open'] > df['High'])
    ]
    if not invalid_ohlc.empty:
        df.drop(invalid_ohlc.index, inplace=True)

    # 5. TẠO CỘT LỢI NHUẬN TẠM THỜI (để xử lý ngoại lai)
    # SỬ DỤNG LOG RETURNS THEO TIÊU CHUẨN THỐNG KÊ (ln(P_t / P_{t-1}))
    df['Temp_Return'] = np.log(df['Adj Close'] / df['Adj Close'].shift(1))
    df.dropna(subset=['Temp_Return'], inplace=True)

    # 6. XỬ LÝ DỮ LIỆU NGOẠI LAI (Outliers - Dùng IQR 3.0x)

    # 6.1. Xử lý Daily Return Outliers
    Q1_ret, Q3_ret = df['Temp_Return'].quantile([0.25, 0.75])
    IQR_ret = Q3_ret - Q1_ret
    lower_bound_ret = Q1_ret - 3.0 * IQR_ret
    upper_bound_ret = Q3_ret + 3.0 * IQR_ret
    df = df[(df['Temp_Return'] > lower_bound_ret) & (df['Temp_Return'] < upper_bound_ret)]

    # 6.2. Xử lý Volume Outliers (Sử dụng cột Volume sau khi đã loại bỏ lỗi Return)
    Q1_vol, Q3_vol = df['Volume'].quantile([0.25, 0.75])
    IQR_vol = Q3_vol - Q1_vol
    upper_bound_vol = Q3_vol + 3.0 * IQR_vol
    df = df[df['Volume'] < upper_bound_vol]

    # 7. TẠO CỘT LỢI NHUẬN CUỐI CÙNG (Log Return)
    df['Daily_Return'] = df['Temp_Return']
    df = df.drop(columns=['Temp_Return'])
    df.dropna(subset=['Daily_Return'], inplace=True)

    print(f"[CLEANING] Hoàn tất làm sạch dữ liệu cho {ticker_symbol}. Số hàng cuối: {len(df)}")

    return df

def download_clean(ticker: str, start: str, end: str = date.today().strftime('%Y-%m-%d'), interval: str = '1d') -> pd.DataFrame:
    """Tải dữ liệu từ yfinance và sau đó làm sạch."""
    print(f"[DOWNLOAD] Tải dữ liệu thô cho {ticker} từ {start} đến {end}...")
    try:
        df_raw = yf.download(ticker, start=start, end=end, interval=interval, progress=False)
        if df_raw.empty:
            raise ValueError("Không tìm thấy dữ liệu.")
    except Exception as e:
        print(f"[ERROR] LỖI TẢI DỮ LIỆU: {e}. Trả về DataFrame rỗng.")
        return pd.DataFrame()

    return clean_financial_data(df_raw, ticker)


# =========================================================================
# === PHẦN 2: PHÂN TÍCH KỸ THUẬT & BACKTEST (TECHNICAL ANALYSIS & EXECUTION) ===
# =========================================================================

# ============================================
# 3) HÀM THÊM CHỈ BÁO KỸ THUẬT (Indicators function)
# ============================================
def add_indicators(df, sma_short=20, sma_long=50, sma_very_long=200, bb_window=20, rsi_window=14, macd_fast=12, macd_slow=26, macd_signal=9, roc_window=126):
    """Tính toán và thêm các chỉ báo kỹ thuật vào DataFrame (sử dụng dữ liệu ĐÃ LÀM SẠCH)."""
    if df.empty:
        print("[INDICATORS] Dữ liệu đầu vào rỗng. Bỏ qua tính toán chỉ báo.")
        return pd.DataFrame()

    print(f"[INDICATORS] Tính toán chỉ báo trên {len(df)} dòng dữ liệu...")

    df = df.copy()

    # 1. MOVING AVERAGES (Xu hướng và Fundamental Proxies)
    df[f'SMA_{sma_short}'] = df['Adj Close'].rolling(sma_short).mean()
    df[f'SMA_{sma_long}']  = df['Adj Close'].rolling(sma_long).mean()
    df[f'EMA_{sma_short}'] = df['Adj Close'].ewm(span=sma_short, adjust=False).mean()
    df[f'SMA_{sma_very_long}'] = df['Adj Close'].rolling(sma_very_long).mean() # Dùng cho Value Proxy

    # 2. VOLATILITY (Bollinger Bands)
    bb = ta.volatility.BollingerBands(close=df['Adj Close'], window=bb_window, window_dev=2)
    df['BB_mid'] = bb.bollinger_mavg()
    df['BB_high'] = bb.bollinger_hband()
    df['BB_low'] 	= bb.bollinger_lband()

    # 3. MOMENTUM (RSI, MACD, ROC, OBV)
    df['RSI'] = ta.momentum.rsi(df['Adj Close'], window=rsi_window)
    macd = ta.trend.MACD(close=df['Adj Close'], window_slow=macd_slow, window_fast=macd_fast, window_sign=macd_signal)
    df['MACD'] = macd.macd()
    df['MACD_signal'] = macd.macd_signal()

    # Rate of Change (Đà giá 6 tháng, 126 ngày)
    df[f'ROC_{roc_window}'] = ta.momentum.roc(df['Adj Close'], window=roc_window)
    # On-Balance Volume (Đà khối lượng)
    df['OBV'] = ta.volume.on_balance_volume(df['Adj Close'], df['Volume'])
    df['OBV_SMA_20'] = df['OBV'].rolling(20).mean()

    df.dropna(inplace=True)
    return df

# ============================================
# 4) HÀM TẠO TÍN HIỆU GIAO DỊCH (Signal generation)
# ============================================
def generate_signals(df):
    """
    Tạo tín hiệu giao dịch cho 4 chiến lược:
    1. SMA Cross (Trend Following)
    2. BB Mean Reversion
    3. Momentum (ROC + OBV)
    4. Value Proxy (Giá/SMA 200)
    5. Growth Proxy (ROC + EMA 20)
    """
    df = df.copy()

    # A. SMA CROSS (TREND FOLLOWING)
    df['signal_sma'] = np.where(df['SMA_20'] > df['SMA_50'], 1, 0)
    df['signal_sma'] = df['signal_sma'].shift(1).fillna(0)

    # B. BB MEAN REVERSION
    buy_cond_bb = (df['Adj Close'] < df['BB_low']) & (df['RSI'] < 35)
    exit_cond_bb = df['Adj Close'] > df['BB_mid']

    position = 0
    bb_signals = []
    for i in range(len(df)):
        if position == 0 and buy_cond_bb.iloc[i]:
            position = 1
        elif position == 1 and exit_cond_bb.iloc[i]:
            position = 0
        bb_signals.append(position)

    df['signal_bb'] = pd.Series(bb_signals, index=df.index).shift(1).fillna(0)

    # C. MOMENTUM (ROC + OBV)
    # Mua: ROC dương VÀ OBV cắt lên đường trung bình 20 ngày
    buy_cond_mom = (df['ROC_126'] > 0) & (df['OBV'] > df['OBV_SMA_20'])
    # Bán: ROC âm HOẶC OBV cắt xuống
    exit_cond_mom = (df['ROC_126'] < 0) | (df['OBV'] < df['OBV_SMA_20'])

    df['signal_momentum'] = np.where(buy_cond_mom, 1, 0)
    df['signal_momentum'] = np.where(exit_cond_mom, 0, df['signal_momentum'])
    df['signal_momentum'] = df['signal_momentum'].shift(1).fillna(0)

    # D. VALUE PROXY (Rẻ tương đối)
    # Mua: Giá < 90% SMA 200 (Rẻ) VÀ ROC 126 không quá âm (Không phải đang sụp đổ)
    buy_cond_value = (df['Adj Close'] < df['SMA_200'] * 0.90) & (df['ROC_126'] > -10)
    # Bán: Giá quay lại đường SMA 200 (Đã hồi phục)
    exit_cond_value = df['Adj Close'] > df['SMA_200'] * 0.95

    df['signal_value'] = np.where(buy_cond_value, 1, 0)
    df['signal_value'] = np.where(exit_cond_value, 0, df['signal_value'])
    df['signal_value'] = df['signal_value'].shift(1).fillna(0)

    # E. GROWTH PROXY (Tăng trưởng mạnh)
    # Mua: ROC 126 > 20% (Tăng trưởng mạnh) VÀ Giá > EMA 20 (Duy trì đà ngắn hạn)
    buy_cond_growth = (df['ROC_126'] > 20) & (df['Adj Close'] > df['EMA_20'])
    # Bán: Giá cắt xuống EMA 20 (Mất đà ngắn hạn)
    exit_cond_growth = df['Adj Close'] < df['EMA_20']

    df['signal_growth'] = np.where(buy_cond_growth, 1, 0)
    df['signal_growth'] = np.where(exit_cond_growth, 0, df['signal_growth'])
    df['signal_growth'] = df['signal_growth'].shift(1).fillna(0)

    # Tín hiệu kết hợp (Trend/Reversion)
    df['signal_any'] = np.where((df['signal_sma'] == 1) | (df['signal_bb'] == 1), 1, 0)

    return df

# ============================================
# 5) HÀM BACKTEST ĐƠN GIẢN (Simple backtester)
# ============================================
def backtest(df, signal_col='signal_any', fee=0.001, slippage=0.0, initial_capital=100000):
    df = df.copy()
    df['position'] = df[signal_col]

    # CHUYỂN ĐỔI: Sử dụng np.expm1 để chuyển Log Returns về Simple Returns cho tính toán Equity
    df['strategy_log_return'] = df['position'].shift(1) * df['Daily_Return']
    df['strategy_log_return'].fillna(0, inplace=True)

    # Phí giao dịch và Slippage (Áp dụng trên Simple Return)
    df['strategy_simple_return'] = np.expm1(df['strategy_log_return']) # Convert Log Return to Simple Return

    df['pos_diff'] = df['position'].diff().abs()
    cost_per_trade = fee + slippage
    df['strategy_return_after_fee'] = df['strategy_simple_return'] - df['pos_diff'] * cost_per_trade

    # Đường cong vốn chủ sở hữu (Equity Curve)
    df['equity'] = initial_capital * (1 + df['strategy_return_after_fee']).cumprod()

    # Benchmark (Buy & Hold)
    df['buy_hold_simple_return'] = np.expm1(df['Daily_Return'])
    df['benchmark_equity'] = initial_capital * (1 + df['buy_hold_simple_return']).cumprod()

    # === Performance Metrics ===
    total_days = (df.index[-1] - df.index[0]).days
    total_years = total_days / 365.25
    final_value = df['equity'].iloc[-1]

    cagr = (final_value / initial_capital) ** (1/total_years) - 1 if total_years > 0 else np.nan
    ann_vol = df['strategy_return_after_fee'].std() * np.sqrt(252)
    sharpe = (df['strategy_return_after_fee'].mean() * 252) / ann_vol if ann_vol > 0 else np.nan
    running_max = df['equity'].cummax()
    max_dd = (df['equity'] / running_max - 1).min()

    # Tính Total Trades & Win Rate
    trades = []

    # PHẢI DÙNG LOG RETURN CHO TỔNG LỢI NHUẬN GIAO DỊCH
    trade_log_return = 0
    in_trade = False

    for i in range(1, len(df)):
        # Vào vị thế (Entry)
        if df['position'].iloc[i] == 1 and df['position'].iloc[i-1] == 0:
            in_trade = True
            trade_log_return = 0

        # Trong vị thế (tính Log Return tích lũy)
        if in_trade and df['position'].iloc[i] == 1:
            # Dùng Log Return ĐÃ TRỪ PHÍ CHO CẢ GIAO DỊCH
            trade_log_return += np.log1p(df['strategy_return_after_fee'].iloc[i])

        # Ra vị thế (Exit)
        elif df['position'].iloc[i] == 0 and df['position'].iloc[i-1] == 1:
            trades.append(np.expm1(trade_log_return)) # Convert back to Simple Return PnL
            in_trade = False

    wins = sum(1 for pnl in trades if pnl > 0)
    losses = len(trades) - wins
    win_rate = wins / len(trades) if len(trades) > 0 else np.nan

    perf = {
        'initial_capital': initial_capital, 'final_value': final_value, 'cagr': cagr,
        'annual_vol': ann_vol, 'sharpe': sharpe, 'max_drawdown': max_dd,
        'win_rate': win_rate, 'n_trades': len(trades)
    }
    return df, perf

# ============================================
# 6) HÀM VẼ ĐỒ THỊ (Plotting utility)
# ============================================
def plot_results(df, perf, title='Strategy', signal_name='signal_any', show_momentum=False):
    """Vẽ biểu đồ giá, chỉ báo RSI và đường vốn chủ sở hữu."""
    # Xác định số lượng panel
    n_panels = 3
    if show_momentum:
        n_panels = 4

    fig, axes = plt.subplots(n_panels, 1, figsize=(14, n_panels*4), sharex=True,
                             gridspec_kw={'height_ratios':([2] + [1]*(n_panels-1))})

    # Đảm bảo axes là một mảng ngay cả khi chỉ có 3 panel
    if n_panels == 3:
        axes = [axes[0], axes[1], axes[2]]

    # 1. Biểu đồ Giá và Tín hiệu
    ax = axes[0]
    ax.plot(df['Adj Close'], label='Adj Close', lw=1.5, color='blue')
    ax.plot(df['SMA_20'], label='SMA 20', lw=1, color='orange', linestyle='--')
    ax.plot(df['SMA_50'], label='SMA 50', lw=1, color='red', linestyle='--')
    ax.plot(df['SMA_200'], label='SMA 200', lw=1, color='purple', linestyle=':') # Thêm SMA 200

    # Bollinger Bands
    ax.fill_between(df.index, df['BB_low'], df['BB_high'], color='gray', alpha=0.1, label='BB 20')

    # Tín hiệu Mua/Bán (Dựa trên cột tín hiệu được truyền vào)
    buys = df[(df[signal_name]==1) & (df[signal_name].shift(1)==0)]
    sells = df[(df[signal_name]==0) & (df[signal_name].shift(1)==1)]
    ax.scatter(buys.index, df.loc[buys.index,'Adj Close'], marker='^', color='green', s=70, label='Entry')
    ax.scatter(sells.index, df.loc[sells.index,'Adj Close'], marker='v', color='red', s=70, label='Exit')
    ax.set_title(title + ' - Price & Indicators', fontsize=16)
    ax.legend(loc='upper left', fontsize=10)
    ax.grid(True)

    # 2. RSI (Vị trí phụ thuộc vào show_momentum)
    rsi_ax = axes[1]
    if show_momentum:
        rsi_ax = axes[2]

    rsi_ax.plot(df['RSI'], label='RSI 14', color='purple')
    rsi_ax.axhline(35, color='darkred', linestyle='--', lw=1)
    rsi_ax.axhline(65, color='darkred', linestyle='--', lw=1)
    rsi_ax.axhline(50, color='gray', linestyle=':', lw=0.5)
    rsi_ax.set_title('RSI (35/65 Thresholds)', fontsize=14)
    rsi_ax.legend(loc='upper left', fontsize=10)
    rsi_ax.grid(True)

    # 3. MOMENTUM PANEL (Nếu được yêu cầu)
    if show_momentum:
        mom_ax = axes[1]
        mom_ax.plot(df['ROC_126'], label='ROC 126d (%)', lw=1.5, color='darkgreen')
        mom_ax.axhline(0, color='red', linestyle='--', lw=1)
        mom_ax.axhline(20, color='purple', linestyle=':', lw=1) # Ngưỡng tăng trưởng
        mom_ax.set_title('Price Momentum (ROC 126d)', fontsize=14)
        mom_ax.legend(loc='upper left', fontsize=10)
        mom_ax.grid(True)

    # 4. Equity curve (Panel cuối cùng)
    eq_ax = axes[-1]
    eq_ax.plot(df['equity'], label='Strategy Equity', lw=2, color='green')
    eq_ax.plot(df['benchmark_equity'], label='Buy & Hold Benchmark', lw=1, color='red', linestyle=':')
    eq_ax.set_ylabel('Equity (USD)', fontsize=12)
    eq_ax.set_title('Equity Curve vs. Benchmark', fontsize=16)
    eq_ax.legend(loc='upper left', fontsize=10)
    eq_ax.grid(True)

    plt.tight_layout()
    plt.show()

    # Print perf
    print("\n" + "="*50)
    print("=== TÓM TẮT HIỆU SUẤT CHIẾN LƯỢC ===")
    print(f"Ticker: {title.split(' - ')[0]}")
    print(f"Giai đoạn Backtest: {df.index.min().strftime('%Y-%m-%d')} đến {df.index.max().strftime('%Y-%m-%d')}")
    print("="*50)
    print(f"Chiến lược: {title.split(' - ')[1]}")
    print(f"Vốn ban đầu (Initial Capital): ${perf['initial_capital']:,.2f}")
    print(f"Giá trị cuối cùng (Final Value): ${perf['final_value']:,.2f}")
    print("-" * 25)
    print(f"Lợi nhuận gộp hàng năm (CAGR): {perf['cagr'] * 100:.2f}%")
    print(f"Sharpe Ratio: {perf['sharpe']:.3f}")
    print(f"Giảm sút tối đa (Max Drawdown): {perf['max_drawdown'] * 100:.2f}%") # Corrected key
    print("-" * 25)
    print(f"Tổng số giao dịch đã đóng (Total Closed Trades): {perf['n_trades']}")
    print(f"Tỷ lệ thắng (Win Rate): {perf['win_rate'] * 100:.2f}%")
    print("="*50)

# ============================================
# 7) RUN FULL PIPELINE (MAIN EXECUTION)
# ============================================
if __name__ == '__main__':
    ticker = 'NVDA' # Thử nghiệm với NVIDIA
    start_date = '2015-01-01'

    # --- BƯỚC 1 & 2: Tải và Làm sạch Dữ liệu (Chỉ chạy 1 lần) ---
    df_cleaned = download_clean(ticker, start=start_date)

    if not df_cleaned.empty:
        # --- BƯỚC 3: Thêm Chỉ báo ---
        df_ind = add_indicators(df_cleaned)

        if not df_ind.empty:
            # --- BƯỚC 4: Tạo Tín hiệu cho TẤT CẢ các chiến lược ---
            df_sign = generate_signals(df_ind)

            # --- BƯỚC 5 & 6: Chạy và Hiển thị từng chiến lược ---
            print("\n================== BẮT ĐẦU BACKTEST (4 CHIẾN LƯỢC) ==================")

            strategies = [
                {'col': 'signal_any', 'title': 'Combined (SMA + BB)'},
                {'col': 'signal_momentum', 'title': 'Pure Momentum (ROC/OBV)', 'show_momentum': True},
                {'col': 'signal_value', 'title': 'Value Proxy (SMA200)'},
                {'col': 'signal_growth', 'title': 'Growth Proxy (ROC/EMA)'},
            ]

            for strategy in strategies:
                df_backtest, perf = backtest(df_sign,
                                            signal_col=strategy['col'],
                                            fee=0.0001, slippage=0.0001,
                                            initial_capital=100000)

                plot_results(df_backtest, perf,
                            title=f"{ticker} - {strategy['title']}",
                            signal_name=strategy['col'],
                            show_momentum=strategy.get('show_momentum', False))

        else:
            print("Không đủ dữ liệu sau khi tính toán chỉ báo (do cần thời gian khởi tạo).")
    else:
        print(f"Quá trình phân tích bị dừng vì dữ liệu cho {ticker} rỗng hoặc lỗi.")