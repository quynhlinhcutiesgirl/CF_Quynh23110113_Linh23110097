# -*- coding: utf-8 -*-
"""Volatility Module

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AWAEuI1vBQ7mA_YO9PgFYIAp-zg3VWfg

volatility model
"""

"""Volatility Module"""

__docformat__ = "google"

import pandas as pd
import numpy as np

from financetoolkit.technicals.overlap_model import get_exponential_moving_average


def get_true_range(
    prices_high: pd.Series, prices_low: pd.Series, prices_close: pd.Series
) -> pd.Series:
    """
    Calculate the Average True Range (ATR) of a given price series.

    TR_t = max(High_t - Low_t, abs(High_t - Close_{t-1}), abs(Low_t - Close_{t-1}))
    Returns:
        pd.Series: True Range values (float), same index as inputs.
    """
    prev_close = prices_close.shift(1)
    # tính phạm vi thực
    true_range = pd.concat(
        [
            prices_high - prices_low,
            abs(prices_high - prev_close).abs(),
            abs(prices_low - prev_close).abs(),
        ],
        axis=1,
    ).max(axis=1)

    return true_range

#tính trung bình true range trong 1 khoảng thời gian bằng SMA hoặc EMA
def get_average_true_range(
    prices_high: pd.Series, prices_low: pd.Series, prices_close: pd.Series, window: int, method: str = "wilder"
) -> pd.Series:
    """
    Calculate the Average True Range (ATR) of a given price series.

    Args:
    ... window: lookback periods (int)
        method: 'wilder' (default) uses Wilder's EMA (common ATR),
                or 'sma' uses simple rolling mean.

    Returns:
        pd.Series: ATR values.
    """
    true_range = get_true_range(prices_high, prices_low, prices_close)
    if method == "wilder":
        # Wilder smoothing: EMA with com = window-1 approximates Wilder's smoothing
        atr = true_range.ewm(com=window - 1, adjust=False, min_periods=window).mean()
    elif method == "sma":
        atr = true_range.rolling(window=window, min_periods=window).mean()
    else:
        raise ValueError("method must be 'wilder' or 'sma'")

    atr.name = f"ATR_{window}"
    return atr.astype(float)

def get_keltner_channels(
    prices_high: pd.Series,
    prices_low: pd.Series,
    prices_close: pd.Series,
    window: int,
    atr_window: int,
    atr_multiplier: float=1.5,
    atr_method: str = "wilder",
) -> pd.DataFrame:
    """
    Calculate the Keltner Channels for a given price series.

    Args:
       Middle line: EMA(prices_close, window) (uses get_exponential_moving_average)
       Upper = Middle + atr_multiplier * ATR(atr_window)
       Lower = Middle - atr_multiplier * ATR(atr_window)
    Returns:
        pd.DataFrame: Keltner Channels (upper, middle, lower).
    """
    # middle_line: ensure EMA uses window and returns a Series with same index
    middle_line = get_exponential_moving_average(prices_close, window)
    middle_line = middle_line.astype(float)
    middle_line.name = "Middle Line"

    atr = get_average_true_range(prices_high, prices_low, prices_close, atr_window, method=atr_method)

    upper_line = (middle_line + atr_multiplier * atr).rename("Upper Line")
    lower_line = (middle_line - atr_multiplier * atr).rename("Lower Line")

    return pd.concat([upper_line, middle_line, lower_line], axis=1)

def get_bollinger_bands(
    prices: pd.Series, window: int, num_std_dev: float = 2.0, ddof: int = 0
) -> pd.DataFrame:
    """
    Calculate the Bollinger Bands of a given price series.

    Args:
       Middle Band = rolling mean (window)
       Std dev = rolling std (window) with ddof (default 0)
       Upper = middle + num_std_dev * std
       Lower = middle - num_std_dev * std
    Returns:
        pd.DataFrame: Bollinger Bands (upper, middle, lower).
    """
    rolling_mean = prices.rolling(window=window, min_periods=window).mean()
    rolling_std = prices.rolling(window=window, min_periods=window).std(ddof=ddof)

    upper_band = (rolling_mean + (num_std_dev * rolling_std)).rename("Upper Band")
    middle_band = rolling_mean.rename("Middle Band")
    lower_band = (rolling_mean - (num_std_dev * rolling_std)).rename("Lower Band")

    close_series = prices.rename("Close").astype(float)

    return pd.concat([upper_band, middle_band, lower_band, close_series], axis=1)