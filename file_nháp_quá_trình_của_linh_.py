# -*- coding: utf-8 -*-
"""file nháp quá trình của linh  .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RDj3q03SHyWo-Dv37Tp-82iRBMjlBYSi

Import the Libraries
"""

!pip install yfinance pandas
!pip install financetoolkit --quiet
!pip install yfinance
!pip install ta

"""tải thư viện

"""

import yfinance as yf
import pandas as pd
from datetime import datetime, date
import numpy as np
from typing import Dict, Union, Any
import matplotlib.pyplot as plt
import ta        # technical analysis indicators
import warnings
from pandas.errors import SettingWithCopyWarning

"""tải dữ liệu ohlc

"""

# --- CẤU HÌNH DỮ LIỆU ---
TICKER = 'META'

# Đặt ngày bắt đầu là một ngày rất xa trong quá khứ
# để đảm bảo tải từ ngày niêm yết (IPO)
START_DATE_REQUEST = '1900-01-01'

# Ngày kết thúc theo yêu cầu
END_DATE = '2025-10-10'

INTERVAL = '1d'

print(f"Bắt đầu tải dữ liệu lịch sử cho {TICKER} từ {START_DATE_REQUEST} đến {END_DATE} (interval: {INTERVAL})...")

try:
    # --- Tải Dữ liệu OHLCV ---
    # Sử dụng ngày 1900-01-01 để chắc chắn bao gồm cả ngày IPO của cổ phiếu
    data = yf.download(
        TICKER,
        start=START_DATE_REQUEST,
        end=END_DATE,
        interval=INTERVAL,
        progress=False
    )

    if data.empty:
        print(f"CẢNH BÁO: Không tìm thấy dữ liệu cho {TICKER} trong khoảng thời gian đã chọn.")
        df_raw = pd.DataFrame()
    else:
        # --- PHÂN TÍCH KẾT QUẢ ---
        actual_start_date = data.index.min().strftime('%Y-%m-%d')
        actual_end_date = data.index.max().strftime('%Y-%m-%d')

        print("\n" + "="*70)
        print(f"--- DỮ LIỆU LỊCH SỬ ĐÃ TẢI THÀNH CÔNG CHO {TICKER} ---")
        print(f"Ngày BẮT ĐẦU DỮ LIỆU THỰC TẾ: {actual_start_date}")
        print(f"Ngày KẾT THÚC DỮ LIỆU THỰC TẾ: {actual_end_date}")
        print(f"Tổng số hàng dữ liệu: {len(data)}")
        print("="*70)
        df_raw = data.copy()

        # Kiểm tra tính hợp lệ của ngày bắt đầu
        if data.index.min().year > 2000:
            print(f"\nCẢNH BÁO: Ngày bắt đầu ({data.index.min().year}) vẫn còn quá gần! Có thể dữ liệu lịch sử đầy đủ chưa được tải.")
        else:
            print("-> Dữ liệu lịch sử có vẻ đã được tải đầy đủ.")

        print("\n5 hàng dữ liệu ĐẦU TIÊN (Lịch sử xa nhất):")
        print(data.head())

        print("\n5 hàng dữ liệu CUỐI CÙNG (Gần ngày 2025-10-10):")
        print(data.tail())

        print("="*70)

except Exception as e:
    print(f"LỖI TẢI DỮ LIỆU: Đã xảy ra lỗi khi tải dữ liệu cho {TICKER}. Lỗi: {e}")
    df_raw = pd.DataFrame()

"""clean data OHLC"""

import yfinance as yf
import pandas as pd
from datetime import datetime, date
import numpy as np
from typing import Dict, Union, Any
import matplotlib.pyplot as plt
import ta        # technical analysis indicators
import warnings
from pandas.errors import SettingWithCopyWarning

# --- CẤU HÌNH DỮ LIỆU (Defined locally for self-containment) ---
TICKER = 'META'
START_DATE_REQUEST = '1900-01-01'
END_DATE = '2025-10-10'
INTERVAL = '1d'

def clean_financial_data(df: pd.DataFrame, ticker_symbol: str) -> pd.DataFrame:
    if df.empty:
        print("DataFrame rỗng, bỏ qua quá trình làm sạch.")
        return pd.DataFrame()

    df = df.copy()

    # --- SỬA LỖI CHÍNH: Định nghĩa price_cols trong phạm vi hàm ---
    price_cols = ['Open', 'High', 'Low', 'Adj Close', 'Volume']

    # --- SỬA LỖI KEYERROR: LÀM PHẲNG CẤU TRÚC CỘT (QUAN TRỌNG) ---
    if isinstance(df.columns, pd.MultiIndex):
        df.columns = df.columns.get_level_values(0)
        print("-> Đã làm phẳng các cột (xử lý MultiIndex).")

    # --- Đảm bảo cột 'Adj Close' tồn tại ---
    if 'Close' in df.columns and 'Adj Close' not in df.columns:
        df = df.rename(columns={'Close': 'Adj Close'})
        print("-> CẢNH BÁO: 'Adj Close' không tìm thấy. Cột 'Close' đã được đổi tên thành 'Adj Close'.")
    elif 'Adj Close' not in df.columns and 'Close' not in df.columns:
        print("LỖI: Cả 'Adj Close' và 'Close' đều không có trong dữ liệu tải về. Không thể tiếp tục.")
        return pd.DataFrame()

    missing_cols = [col for col in price_cols if col not in df.columns]
    if missing_cols:
        # Lỗi NameError đã được khắc phục ở đây
        print(f"LỖI: Các cột cần thiết bị thiếu: {missing_cols}. Không thể làm sạch.")
        return pd.DataFrame()

    # --- BƯỚC 1: ĐẢM BẢO TÍNH NHẤT QUÁN & SẮP XẾP ---
    df.index = pd.to_datetime(df.index)
    df = df.sort_index()

    # --- BƯỚC 2: XỬ LÝ DỮ LIỆU THIẾU (MISSING DATA - NaN) ---
    print("\n2. Xử lý dữ liệu thiếu (NaN) bằng Forward Fill/Backward Fill...")
    df[price_cols] = df[price_cols].ffill().bfill() # Kết hợp ffill và bfill

    original_rows = len(df)
    df.dropna(subset=['Adj Close'], inplace=True)
    if original_rows > len(df):
        print(f" \t-> Đã xóa {original_rows - len(df)} hàng vẫn còn NaN sau khi điền.")


    # --- BƯỚC 3: XỬ LÝ VOLUME = 0 HOẶC VÔ LÝ ---
    print("3. Xử lý các ngày có Khối lượng = 0...")
    original_rows = len(df)
    df = df[df['Volume'] > 0]
    removed_volume_rows = original_rows - len(df)

    if removed_volume_rows > 0:
        print(f" \t-> Đã xóa {removed_volume_rows} hàng có Volume <= 0.")

    # --- BƯỚC 4: KIỂM TRA VÀ XỬ LÝ DỮ LIỆU LỖI OHLC ---
    print("4. Kiểm tra lỗi OHLC (High < Low, v.v.)...")
    invalid_ohlc = df[
        (df['Low'] > df['High']) |
        (df['Adj Close'] > df['High']) |
        (df['Adj Close'] < df['Low']) |
        (df['Open'] < df['Low']) |
        (df['Open'] > df['High'])
    ]

    if not invalid_ohlc.empty:
        removed_ohlc_rows = len(invalid_ohlc)
        df.drop(invalid_ohlc.index, inplace=True)
        print(f" \t-> Đã xóa {removed_ohlc_rows} hàng bị lỗi OHLC.")

    # --- BƯỚC 5 : XỬ LÝ DỮ LIỆU NGOẠI LAI (Outliers) ---
    print("\n5. Xử lý dữ liệu ngoại lai (Outliers) bằng phương pháp IQR (trên Volume và Daily Return)...")

    # 5.1. Xử lý Volume Outliers (Giả định Volume quá lớn là ngoại lai)
    Q1_vol = df['Volume'].quantile(0.25)
    Q3_vol = df['Volume'].quantile(0.75)
    IQR_vol = Q3_vol - Q1_vol
    # Sử dụng hệ số 3.0 (thay vì 1.5) để chỉ loại bỏ các giá trị cực đoan
    upper_bound_vol = Q3_vol + 3.0 * IQR_vol

    original_rows_vol = len(df)
    # Giữ lại các hàng có Volume nhỏ hơn ngưỡng trên
    df = df[df['Volume'] < upper_bound_vol]

    removed_outlier_vol_rows = original_rows_vol - len(df)
    if removed_outlier_vol_rows > 0:
        print(f" \t-> Đã xóa {removed_outlier_vol_rows} hàng có Volume quá lớn (> 3x IQR).")

    # 5.2. Xử lý Daily Return Outliers (Lợi nhuận cực đoan)
    # Tạo cột Daily_Return TẠM THỜI (vì nó sẽ được tính lại ở Bước 6)
    df['Temp_Return'] = df['Adj Close'].pct_change()
    df.dropna(subset=['Temp_Return'], inplace=True)

    Q1_ret = df['Temp_Return'].quantile(0.25)
    Q3_ret = df['Temp_Return'].quantile(0.75)
    IQR_ret = Q3_ret - Q1_ret
    # Sử dụng hệ số 3.0 cho ngưỡng trên và dưới
    lower_bound_ret = Q1_ret - 3.0 * IQR_ret
    upper_bound_ret = Q3_ret + 3.0 * IQR_ret

    original_rows_ret = len(df)
    # Loại bỏ các hàng có Daily Return quá lớn hoặc quá nhỏ
    df = df[(df['Temp_Return'] > lower_bound_ret) & (df['Temp_Return'] < upper_bound_ret)]

    removed_ret_outlier_rows = original_rows_ret - len(df)
    if removed_ret_outlier_rows > 0:
        print(f" \t-> Đã xóa {removed_ret_outlier_rows} hàng có Daily Return ngoại lai (> 3x IQR).")
    # Loại bỏ cột tạm thời
    df = df.drop(columns=['Temp_Return'])

    # --- BƯỚC 6 (BƯỚC 5 CŨ): TẠO CỘT LỢI NHUẬN CUỐI CÙNG ---
    df['Daily_Return'] = df['Adj Close'].pct_change()
    df.dropna(subset=['Daily_Return'], inplace=True) # Hàng đầu tiên luôn là NaN

    print("\n" + "="*50)
    print(f"QUÁ TRÌNH LÀM SẠCH HOÀN TẤT CHO {ticker_symbol}.")
    print(f"Số hàng dữ liệu cuối cùng: {len(df)}")
    print("="*50)

    return df
# ============================================
# 2) HÀM TẢI VÀ LÀM SẠCH (Download and Clean)
# ============================================
def download_and_clean(ticker: str, start: str, end: str = date.today().strftime('%Y-%m-%d'), interval: str = '1d') -> pd.DataFrame:
    """Tải dữ liệu từ yfinance và sau đó làm sạch bằng clean_financial_data."""
    try:
        df_raw = yf.download(
            ticker,
            start=start,
            end=end,
            interval=interval,
            progress=False
        )
        if df_raw.empty:
            raise ValueError("Không tìm thấy dữ liệu.")
    except Exception as e:
        print(f"[DATA PIPELINE] LỖI TẢI DỮ LIỆU: {e}.")
        return pd.DataFrame()

    # Gọi hàm làm sạch
    return clean_financial_data(df_raw, ticker)

# ============================================
# 3. CHẠY CODE VÀ HIỂN THỊ KẾT QUẢ
# ============================================
print("\n" + "#"*50)
print("BẮT ĐẦU GỌI HÀM LÀM SẠCH")
print("#"*50)
# Changed to use download_and_clean function to ensure df_raw is defined.
cleaned_data = download_and_clean(TICKER, START_DATE_REQUEST, END_DATE, INTERVAL)

if not cleaned_data.empty:
    print("\n5 HÀNG DỮ LIỆU ĐÃ ĐƯỢC LÀM SẠCH CUỐI CÙNG:")
    print(cleaned_data.tail())

"""Download fundamental data"""

class FinancialMetricsCalculator:
    """
    Lớp dùng để tải dữ liệu tài chính từ yfinance, tính toán các chỉ số quan trọng
    (Thanh khoản, Sinh lời, Định giá) và hiển thị kết quả.
    """
    def __init__(self, ticker_symbol: str):
        self.ticker = yf.Ticker(ticker_symbol)
        self.symbol = ticker_symbol
        self.data: Dict[str, Any] = {}
        self.report_date: str = "N/A"
        self._load_data()
        self._validate_data()

    def _get(self, key: str) -> float:
        """Lấy giá trị từ self.data, trả về 0.0 nếu thiếu hoặc là None."""
        value = self.data.get(key)
        if value is None or (isinstance(value, (int, float)) and np.isnan(value)):
            return 0.0
        return float(value)

    def _safe_divide(self, numerator: float, denominator: float) -> float:
        """Chia an toàn, trả về np.inf nếu chia cho 0."""
        if denominator == 0:
            return np.inf if numerator > 0 else 0.0
        return numerator / denominator

    def _load_data(self):
        """Tải dữ liệu thô và áp dụng cơ chế xử lý lỗi đa dạng (đa Key) cho các trường tài chính."""
        info = self.ticker.info
        income_statement = self.ticker.financials
        balance_sheet = self.ticker.balance_sheet
        cash_flow = self.ticker.cashflow

        # 1. TRÍCH XUẤT NGÀY BÁO CÁO (Sửa lỗi đổi tên cột)
        try:
            date_col = income_statement.columns[0]
            self.report_date = pd.to_datetime(date_col).strftime('%Y-%m-%d')
        except Exception:
            self.report_date = "Lỗi trích xuất ngày"

        # 2. DỮ LIỆU THỊ TRƯỜNG & KHỞI TẠO CÁC DF SỬ DỤNG
        self.data['Share Price'] = info.get('currentPrice', 0)
        self.data['Shares Outstanding'] = info.get('sharesOutstanding', 0)

        latest_is = income_statement.iloc[:, 0].to_dict()
        latest_bs = balance_sheet.iloc[:, 0].to_dict()
        latest_cf = cash_flow.iloc[:, 0].to_dict()

        # 3. TRÍCH XUẤT BÁO CÁO KẾT QUẢ KINH DOANH (IS)
        self.data['Total Revenue'] = latest_is.get('Total Revenue', 0)
        self.data['Net Income'] = latest_is.get('Net Income', 0)
        self.data['Cost Of Revenue'] = latest_is.get('Cost Of Revenue', 0)

        # Lấy EBIT (Lãi trước thuế và lãi vay): Thử 2 tên phổ biến nhất
        ebit = latest_is.get('Ebit', latest_is.get('Operating Income', 0))
        self.data['EBIT'] = ebit

        # Lấy Interest Expense (Chi phí Lãi vay): Thử 2 tên phổ biến nhất
        interest = latest_is.get('Interest Expense', latest_is.get('Interest expense', 0))
        self.data['Interest Expense'] = interest

        # 4. TRÍCH XUẤT BẢNG CÂN ĐỐI KẾ TOÁN (BS)
        self.data['Total Assets'] = latest_bs.get('Total Assets', latest_bs.get('Assets', 0))
        self.data['Total Shareholders Equity'] = latest_bs.get('Total Stockholder Equity', latest_bs.get('Stockholders Equity', 0))

        # Thanh khoản
        self.data['Total Current Assets'] = latest_bs.get('Total Current Assets', latest_bs.get('Current Assets', 0))
        self.data['Total Current Liabilities'] = latest_bs.get('Total Current Liabilities', latest_bs.get('Current Liabilities', 0))
        self.data['Inventory'] = latest_bs.get('Inventory', 0)

        # Nợ (Tổng Nợ Phải Trả)
        self.data['Total Liabilities'] = latest_bs.get('Total Liabilities', latest_bs.get('Total Liab', 0))


        # 5. TRÍCH XUẤT BÁO CÁO LƯU CHUYỂN TIỀN TỆ (CF)
        # CFO (Cash Flow from Operations): Thử 3 tên phổ biến nhất
        cfo = latest_cf.get('Total Cash From Operating Activities', latest_cf.get('Cash Flow From Operations', latest_cf.get('Operating Cash Flow', 0)))
        self.data['CFO'] = cfo

        # CAPEX (Capital Expenditures): Thử 2 tên phổ biến nhất
        capex = latest_cf.get('Capital Expenditures', latest_cf.get('Capital expenditure', 0))
        self.data['CAPEX'] = capex

        # Dividends Paid
        self.data['Total Dividends Paid'] = abs(latest_cf.get('Common Stock Dividend Paid', 0))

    def _validate_data(self):
        """Kiểm tra và in cảnh báo nếu thiếu các trường dữ liệu quan trọng."""
        required_fields = [
            'Total Revenue', 'Net Income', 'Shares Outstanding', 'Share Price',
            'Total Shareholders Equity', 'Total Assets', 'Total Current Liabilities'
        ]

        missing = [field for field in required_fields if self._get(field) == 0.0]
        if missing:
            print(f"CẢNH BÁO: Dữ liệu bị thiếu hoặc bằng 0 cho {', '.join(missing)}.")
            print("Các chỉ số liên quan sẽ trả về 0.0 hoặc N/A.")

    # --- METRICS (Tính toán các chỉ số) ---

    # 1. PER SHARE & MARKET
    def earnings_per_share(self) -> float:
        """Công thức: Lợi Nhuận Ròng / Số Cổ Phần Đang Lưu Hành"""
        return self._safe_divide(self._get('Net Income'), self._get('Shares Outstanding'))

    def book_value_per_share(self) -> float:
        """Công thức: Tổng Vốn Chủ Sở Hữu / Số Cổ Phần Đang Lưu Hành"""
        return self._safe_divide(self._get('Total Shareholders Equity'), self._get('Shares Outstanding'))

    def price_to_earnings_ratio(self) -> float:
        """Công thức: Giá Cổ Phiếu / EPS"""
        eps = self.earnings_per_share()
        return self._safe_divide(self._get('Share Price'), eps)

    # 2. LIQUIDITY (Thanh khoản)
    def current_ratio(self) -> float:
        """Công thức: Tài sản ngắn hạn / Nợ ngắn hạn"""
        return self._safe_divide(self._get('Total Current Assets'), self._get('Total Current Liabilities'))

    def quick_ratio(self) -> float:
        """Công thức: (Tài sản ngắn hạn - Hàng tồn kho) / Nợ ngắn hạn"""
        numerator = self._get('Total Current Assets') - self._get('Inventory')
        return self._safe_divide(numerator, self._get('Total Current Liabilities'))

    # 3. LEVERAGE (Cơ cấu vốn)
    def debt_to_equity_ratio(self) -> float:
        """Công thức: Tổng Nợ / Tổng Vốn Chủ Sở Hữu"""
        return self._safe_divide(self._get('Total Liabilities'), self._get('Total Shareholders Equity'))

    def interest_coverage_ratio(self) -> float:
        """Công thức: EBIT / Chi phí Lãi vay"""
        return self._safe_divide(self._get('EBIT'), self._get('Interest Expense'))

    # 4. PROFITABILITY (Sinh lời)
    def gross_margin(self) -> float:
        """Công thức: (Doanh thu - Giá vốn) / Doanh thu"""
        gross_profit = self._get('Total Revenue') - self._get('Cost Of Revenue')
        return self._safe_divide(gross_profit, self._get('Total Revenue')) * 100

    def net_margin(self) -> float:
        """Công thức: Lợi nhuận ròng / Doanh thu"""
        return self._safe_divide(self._get('Net Income'), self._get('Total Revenue')) * 100

    def return_on_equity(self) -> float:
        """Công thức: Lợi Nhuận Ròng / Tổng Vốn Chủ Sở Hữu"""
        return self._safe_divide(self._get('Net Income'), self._get('Total Shareholders Equity')) * 100

    def return_on_assets(self) -> float:
        """Công thức: Lợi Nhuận Ròng / Tổng Tài Sản"""
        return self._safe_divide(self._get('Net Income'), self._get('Total Assets')) * 100

    # 5. CASH FLOW (Dòng tiền)
    def free_cash_flow(self) -> float:
        """Công thức: CFO - CAPEX"""
        return self._get('CFO') + self._get('CAPEX') # yfinance CAPEX thường âm, nên dùng phép cộng

    def calculate_all(self):
        """Tính toán và hiển thị tất cả các chỉ số."""
        results = {
            # Thanh khoản
            'Current Ratio': self.current_ratio(),
            'Quick Ratio': self.quick_ratio(),
            # Cơ cấu vốn
            'Debt to Equity (D/E)': self.debt_to_equity_ratio(),
            'Interest Coverage': self.interest_coverage_ratio(),
            # Sinh lời
            'Gross Margin (%)': self.gross_margin(),
            'Net Margin (%)': self.net_margin(),
            'Return on Equity (ROE) (%)': self.return_on_equity(),
            'Return on Assets (ROA) (%)': self.return_on_assets(),
            # Thị trường & Dòng tiền
            'Earnings per Share (EPS)': self.earnings_per_share(),
            'Price to Earnings (P/E)': self.price_to_earnings_ratio(),
            'Book Value per Share (BPS)': self.book_value_per_share(),
            'Free Cash Flow (FCF)': self.free_cash_flow(),
        }

        # Định dạng kết quả thành DataFrame để hiển thị
        df = pd.DataFrame(list(results.items()), columns=['Metric', 'Value'])

        def format_value(row):
            val = row['Value']
            metric = row['Metric']

            if val == np.inf:
                return "Rất Cao"
            if '(%)' in metric:
                return f"{val:.2f}%"
            if 'per Share' in metric or 'FCF' in metric:
                return f"${val:,.2f}"
            return f"{val:.2f}x"

        df['Formatted Value'] = df.apply(format_value, axis=1)

        # Thêm nhóm phân tích để hiển thị đẹp hơn
        groups = {
            'Current Ratio': '1. Thanh khoản', 'Quick Ratio': '1. Thanh khoản',
            'Debt to Equity (D/E)': '2. Cơ cấu Vốn', 'Interest Coverage': '2. Cơ cấu Vốn',
            'Gross Margin (%)': '3. Sinh lời', 'Net Margin (%)': '3. Sinh lời',
            'Return on Equity (ROE) (%)': '3. Sinh lời', 'Return on Assets (ROA) (%)': '3. Sinh lời',
            'Earnings per Share (EPS)': '4. Thị trường', 'Price to Earnings (P/E)': '4. Thị trường',
            'Book Value per Share (BPS)': '4. Thị trường',
            'Free Cash Flow (FCF)': '5. Dòng tiền',
        }
        df['Nhóm Phân tích'] = df['Metric'].map(groups)

        df_display = df.set_index('Nhóm Phân tích')[['Metric', 'Formatted Value']]

        # Hiển thị thông tin
        print("\n" + "="*70)
        print(f"--- PHÂN TÍCH CƠ BẢN CHO CỔ PHIẾU {self.symbol} ---")
        print(f"Ngày báo cáo gần nhất: {self.report_date}")
        print(f"Giá cổ phiếu hiện tại: ${self._get('Share Price'):,.2f}")
        print("="*70)

        print(df_display.to_string(index=True, header=True))
        print("="*70)

        return results

### Áp dụng để tải fundamental cho các mã cổ phiếu

SYMBOL = 'META'

print(f"Bắt đầu tải dữ liệu và tính toán cho {SYMBOL}...")
calculator = FinancialMetricsCalculator(SYMBOL)
calculator.calculate_all()

"""technical indicators"""

# SỬA LỖI: Thay thế style 'seaborn-darkgrid' dễ bị lỗi bằng style 'ggplot' hoặc 'fivethirtyeight' ổn định hơn
plt.style.use('ggplot')

# ============================================
# 4) Indicators function
# ============================================
def add_indicators(df, sma_short=20, sma_long=50, bb_window=20, rsi_window=14, macd_fast=12, macd_slow=26, macd_signal=9):
  if df.empty:
        print("[INDICATORS] Dữ liệu đầu vào rỗng. Bỏ qua tính toán chỉ báo.")
        return pd.DataFrame()
  df = df.copy()
  # SMA & EMA
  df[f'SMA_{sma_short}'] = df['Adj Close'].rolling(sma_short).mean()
  df[f'SMA_{sma_long}']  = df['Adj Close'].rolling(sma_long).mean()
  df[f'EMA_{sma_short}'] = df['Adj Close'].ewm(span=sma_short, adjust=False).mean()

  # Bollinger Bands
  bb = ta.volatility.BollingerBands(close=df['Adj Close'], window=bb_window, window_dev=2)
  df['BB_mid'] = bb.bollinger_mavg()
  df['BB_high'] = bb.bollinger_hband()
  df['BB_low']  = bb.bollinger_lband()

  # RSI
  df['RSI'] = ta.momentum.rsi(df['Adj Close'], window=rsi_window)

  # MACD
  macd = ta.trend.MACD(close=df['Adj Close'], window_slow=macd_slow, window_fast=macd_fast, window_sign=macd_signal)
  df['MACD'] = macd.macd()
  df['MACD_signal'] = macd.macd_signal()

  df.dropna(inplace=True)
  return df

# ============================================
# 5) Signal generation examples
# ============================================
def generate_signals(df):
    df = df.copy()
    # Initialize
    df['signal_sma'] = 0
    df['signal_bb']  = 0

    # A) SMA cross: 1 = long, 0 = flat
    df['signal_sma'] = np.where(df['SMA_20'] > df['SMA_50'], 1, 0)
    # Dịch tín hiệu: signal_t-1 quyết định position_t. Tránh lookahead.
    df['signal_sma'] = df['signal_sma'].shift(1).fillna(0)

    # B) BB mean reversion: buy when price < lower band and RSI < 35, sell when price > mid band
    buy_cond = (df['Adj Close'] < df['BB_low']) & (df['RSI'] < 35)
    exit_cond = df['Adj Close'] > df['BB_mid']

    position = 0
    bb_signals = []
    # Vòng lặp để mô phỏng trạng thái (state machine)
    for i in range(len(df)):
        if position == 0 and buy_cond.iloc[i]:
            position = 1
        elif position == 1 and exit_cond.iloc[i]:
            position = 0
        bb_signals.append(position)

    # Dịch tín hiệu: signal_t-1 quyết định position_t. Tránh lookahead.
    df['signal_bb'] = pd.Series(bb_signals, index=df.index).shift(1).fillna(0)

    # Combine strategies option
    df['signal_any'] = np.where((df['signal_sma'] == 1) | (df['signal_bb'] == 1), 1, 0)
    return df

# ============================================
# 6) Simple backtester
# ============================================
def backtest(df, signal_col='signal_any', fee=0.001, slippage=0.0, initial_capital=100000):
    df = df.copy()
    df['position'] = df[signal_col]    # 1 if long, 0 if flat

    # Lợi nhuận của chiến lược: position_{t-1} * return_t
    df['strategy_return'] = df['position'].shift(1) * df['Daily_Return']
    df['strategy_return'].fillna(0, inplace=True)

    # Phí giao dịch và Slippage
    df['pos_diff'] = df['position'].diff().abs() # Ngày có giao dịch (entry/exit)

    # Trừ phí: Phí (fee + slippage) được trừ trực tiếp vào lợi nhuận ngày giao dịch
    cost_per_trade = fee + slippage
    df['strategy_return_after_fee'] = df['strategy_return'] - df['pos_diff'] * cost_per_trade

    # Đường cong vốn chủ sở hữu (Equity Curve)
    df['equity'] = initial_capital * (1 + df['strategy_return_after_fee']).cumprod()

    # Benchmark (Buy & Hold)
    df['buy_hold_return'] = df['Daily_Return']
    df['benchmark_equity'] = initial_capital * (1 + df['buy_hold_return']).cumprod()

    # === Performance Metrics ===
    total_days = (df.index[-1] - df.index[0]).days
    total_years = total_days / 365.25
    final_value = df['equity'].iloc[-1]

    # CAGR
    cagr = (final_value / initial_capital) ** (1/total_years) - 1 if total_years > 0 else np.nan
    # Annual Volatility
    ann_vol = df['strategy_return_after_fee'].std() * np.sqrt(252)
    # Sharpe Ratio (Giả định lãi suất phi rủi ro = 0)
    sharpe = (df['strategy_return_after_fee'].mean() * 252) / ann_vol if ann_vol > 0 else np.nan

    # Max Drawdown
    running_max = df['equity'].cummax()
    dd = df['equity'] / running_max - 1
    max_dd = dd.min()

    # SỬA LỖI LOGIC: Đơn giản hóa việc tính Win Rate bằng cách tính PnL theo chuỗi
    # Chỉ xem xét các giao dịch đã đóng (Closed Trades)
    trades = []
    trade_return = 0
    in_trade = False

    for i in range(1, len(df)):
        # Vào vị thế (Entry)
        if df['position'].iloc[i] == 1 and df['position'].iloc[i-1] == 0:
            in_trade = True
            trade_return = 0

        # Trong vị thế
        if in_trade and df['position'].iloc[i] == 1:
            # Lợi nhuận hàng ngày trong vị thế (đã trừ phí cho ngày vào lệnh)
            trade_return += df['strategy_return_after_fee'].iloc[i]

        # Ra vị thế (Exit)
        elif df['position'].iloc[i] == 0 and df['position'].iloc[i-1] == 1:
            trades.append(trade_return)
            in_trade = False

    wins = sum(1 for pnl in trades if pnl > 0)
    losses = len(trades) - wins
    win_rate = wins / len(trades) if len(trades) > 0 else np.nan

    perf = {
        'initial_capital': initial_capital,
        'final_value': final_value,
        'cagr': cagr,
        'annual_vol': ann_vol,
        'sharpe': sharpe,
        'max_drawdown': max_dd,
        'win_rate': win_rate,
        'n_trades': len(trades)
    }
    return df, perf

# ============================================
# 7) Plotting utility
# ============================================
def plot_results(df, perf, title='Strategy'):
    fig, axes = plt.subplots(3,1, figsize=(14,14), sharex=True,
                             gridspec_kw={'height_ratios':[2,1,1]})

    # 1. Biểu đồ Giá và Tín hiệu
    ax = axes[0]
    ax.plot(df['Adj Close'], label='Adj Close', lw=1.5, color='blue')
    ax.plot(df['SMA_20'], label='SMA 20', lw=1, color='orange', linestyle='--')
    ax.plot(df['SMA_50'], label='SMA 50', lw=1, color='red', linestyle='--')

    # Bollinger Bands
    ax.fill_between(df.index, df['BB_low'], df['BB_high'], color='gray', alpha=0.1, label='BB 20')

    # Tín hiệu Mua/Bán
    buys = df[(df['position']==1) & (df['position'].shift(1)==0)]
    sells = df[(df['position']==0) & (df['position'].shift(1)==1)]
    ax.scatter(buys.index, df.loc[buys.index,'Adj Close'], marker='^', color='green', s=70, label='Entry')
    ax.scatter(sells.index, df.loc[sells.index,'Adj Close'], marker='v', color='red', s=70, label='Exit')
    ax.set_title(title + ' - Price & Indicators', fontsize=16)
    ax.legend(loc='upper left', fontsize=10)
    ax.grid(True)

    # 2. RSI
    axes[1].plot(df['RSI'], label='RSI 14', color='purple')
    axes[1].axhline(35, color='darkred', linestyle='--', lw=1)
    axes[1].axhline(65, color='darkred', linestyle='--', lw=1)
    axes[1].axhline(50, color='gray', linestyle=':', lw=0.5)
    axes[1].set_title('RSI (35/65 Thresholds)', fontsize=14)
    axes[1].legend(loc='upper left', fontsize=10)
    axes[1].grid(True)

    # 3. Equity curve
    axes[2].plot(df['equity'], label='Strategy Equity', lw=2, color='green')
    axes[2].plot(df['benchmark_equity'], label='Buy & Hold Benchmark', lw=1, color='red', linestyle=':')
    axes[2].set_ylabel('Equity (USD)', fontsize=12)
    axes[2].set_title('Equity Curve vs. Benchmark', fontsize=16)
    axes[2].legend(loc='upper left', fontsize=10)
    axes[2].grid(True)

    plt.tight_layout()
    plt.show()

    # Print perf
    print("\n" + "="*50)
    print("=== TÓM TẮT HIỆU SUẤT CHIẾN LƯỢC ===")
    print(f"Ticker: {title.split(' - ')[0]}")
    print(f"Giai đoạn Backtest: {df.index.min().strftime('%Y-%m-%d')} đến {df.index.max().strftime('%Y-%m-%d')}")
    print("="*50)
    print(f"Vốn ban đầu (Initial Capital): ${perf['initial_capital']:,.2f}")
    print(f"Giá trị cuối cùng (Final Value): ${perf['final_value']:,.2f}")
    print("-" * 25)
    print(f"Lợi nhuận gộp hàng năm (CAGR): {perf['cagr'] * 100:.2f}%")
    print(f"Sharpe Ratio: {perf['sharpe']:.3f}")
    print(f"Biến động hàng năm (Annual Vol): {perf['annual_vol'] * 100:.2f}%")
    print(f"Giảm sút tối đa (Max Drawdown): {perf['max_drawdown'] * 100:.2f}%")
    print("-" * 25)
    print(f"Tổng số giao dịch (Total Trades): {perf['n_trades']}")
    print(f"Tỷ lệ thắng (Win Rate): {perf['win_rate'] * 100:.2f}%")
    print("="*50)

# ============================================
# 8) Run full pipeline: example with META (or any ticker)
# ============================================
ticker = 'META'
df_raw = download_and_clean(ticker, start='2015-01-01')
df_ind = add_indicators(df_raw, sma_short=20, sma_long=50, bb_window=20, rsi_window=14)
df_sign = generate_signals(df_ind)
# Giảm phí giao dịch và slippage
df_backtest, perf = backtest(df_sign, signal_col='signal_any', fee=0.0001, slippage=0.0001, initial_capital=100000)
plot_results(df_backtest, perf, title=f"{ticker} - SMA20/SMA50 + BB Mean Reversion")

# ============================================
# 9) Next steps & tuning
# ============================================
print("\nNext steps you can do:")
print(" - Grid search parameters (SMA windows, BB window, RSI threshold)")
print(" - Use walk-forward/backtest (train on past window, test next window)")
print(" - Add portfolio-level backtester to test multiple tickers and equal/vol-weighted sizing")
print(" - Include position sizing rules: volatility targeting, risk-per-trade")
print(" - Add slippage model and realistic execution (market open/close fills)")

"""cách 2"""

import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import ta
from datetime import date
import warnings
from pandas.errors import SettingWithCopyWarning
warnings.filterwarnings('ignore', category=SettingWithCopyWarning)
plt.style.use('ggplot')

# =========================================================================
# === PHẦN 1: TẢI VÀ LÀM SẠCH DỮ LIỆU (DATA ACQUISITION & CLEANING) ===
# (Phần này được giữ nguyên để đảm bảo dữ liệu đầu vào luôn sạch)
# =========================================================================

def clean_financial_data(df: pd.DataFrame, ticker_symbol: str) -> pd.DataFrame:
    """Xử lý dữ liệu tài chính thô, bao gồm xử lý NaN, lỗi OHLC, và ngoại lai."""
    if df.empty:
        return pd.DataFrame()

    df = df.copy()
    price_cols = ['Open', 'High', 'Low', 'Adj Close', 'Volume']

    if isinstance(df.columns, pd.MultiIndex):
        df.columns = df.columns.get_level_values(0)
    if 'Close' in df.columns and 'Adj Close' not in df.columns:
        df = df.rename(columns={'Close': 'Adj Close'})

    df.index = pd.to_datetime(df.index)
    df = df.sort_index()
    df[price_cols] = df[price_cols].ffill().bfill()
    df.dropna(subset=['Adj Close'], inplace=True)
    df = df[df['Volume'] > 0]

    df['Temp_Return'] = df['Adj Close'].pct_change()
    df.dropna(subset=['Temp_Return'], inplace=True)
    Q1_ret, Q3_ret = df['Temp_Return'].quantile([0.25, 0.75])
    IQR_ret = Q3_ret - Q1_ret
    lower_bound_ret = Q1_ret - 3.0 * IQR_ret
    upper_bound_ret = Q3_ret + 3.0 * IQR_ret
    df = df[(df['Temp_Return'] > lower_bound_ret) & (df['Temp_Return'] < upper_bound_ret)]
    df = df.drop(columns=['Temp_Return'])

    df['Daily_Return'] = df['Adj Close'].pct_change()
    df.dropna(subset=['Daily_Return'], inplace=True)

    return df

def download_clean(ticker: str, start: str, end: str = date.today().strftime('%Y-%m-%d'), interval: str = '1d') -> pd.DataFrame:
    """Tải dữ liệu từ yfinance và sau đó làm sạch."""
    try:
        df_raw = yf.download(ticker, start=start, end=end, interval=interval, progress=False)
        if df_raw.empty:
            raise ValueError("Không tìm thấy dữ liệu.")
    except Exception as e:
        print(f"[ERROR] LỖI TẢI DỮ LIỆU: {e}.")
        return pd.DataFrame()

    return clean_financial_data(df_raw, ticker)

# =========================================================================
# === PHẦN 2: THÊM INDICATORS & CHIẾN LƯỢC MỚI =============================
# =========================================================================

def add_indicators(df, sma_short=20, sma_long=50, sma_very_long=200, bb_window=20, rsi_window=14):
    """
    Tính toán và thêm các chỉ báo kỹ thuật, bao gồm cả các chỉ báo cho chiến lược
    Momentum (ROC, OBV) và Fundamental Proxy (SMA 200).
    """
    if df.empty:
        print("[INDICATORS] Dữ liệu đầu vào rỗng.")
        return pd.DataFrame()

    df = df.copy()

    # 1. Trend & Basic Indicators
    df[f'SMA_{sma_short}'] = df['Adj Close'].rolling(sma_short).mean()
    df[f'SMA_{sma_long}'] 	= df['Adj Close'].rolling(sma_long).mean()
    df[f'SMA_{sma_very_long}'] = df['Adj Close'].rolling(sma_very_long).mean() # Dùng cho Value Proxy
    df[f'EMA_{sma_short}'] = df['Adj Close'].ewm(span=sma_short, adjust=False).mean()

    bb = ta.volatility.BollingerBands(close=df['Adj Close'], window=bb_window, window_dev=2)
    df['BB_mid'] = bb.bollinger_mavg()
    df['BB_high'] = bb.bollinger_hband()
    df['BB_low'] 	= bb.bollinger_lband()
    df['RSI'] = ta.momentum.rsi(df['Adj Close'], window=rsi_window)

    # 2. Indicators for Momentum and Fundamental Proxy

    # Momenmtum Giá (6 tháng): Rate of Change (126 ngày giao dịch)
    roc_window = 126
    df[f'ROC_{roc_window}'] = ta.momentum.roc(df['Adj Close'], window=roc_window)

    # Momentum Khối lượng: On-Balance Volume (OBV)
    df['OBV'] = ta.volume.on_balance_volume(df['Adj Close'], df['Volume'])
    # OBV Signal Line (SMA của OBV)
    obv_signal_window = 20
    df[f'OBV_SMA_{obv_signal_window}'] = df['OBV'].rolling(obv_signal_window).mean()

    df.dropna(inplace=True)

    if df.empty:
        print("[INDICATORS] Sau khi tính toán chỉ báo (đặc biệt là SMA 200), DataFrame bị rỗng.")

    return df

def generate_signals(df):
    """
    Tạo các tín hiệu giao dịch cho 3 chiến lược:
    1. SMA Cross/BB (Trend/Reversion - Existing)
    2. Momentum (Price + Volume)
    3. Fundamental Proxy (Value/Growth Proxy)
    """
    df = df.copy()

    # Khởi tạo các cột tín hiệu mới
    df['signal_momentum'] = 0
    df['signal_value'] = 0
    df['signal_growth'] = 0

    # --- 1. Momentum Strategy (Price ROC + Volume OBV) ---
    # Buy: ROC 126 (6-tháng) dương VÀ OBV cắt lên đường Signal (OBV_SMA_20)

    # OBV Crossover: 1 nếu OBV > OBV_SMA, 0 nếu ngược lại
    df['OBV_Crossover'] = np.where(df['OBV'] > df['OBV_SMA_20'], 1, 0)

    # Tín hiệu Mua Momentum
    momentum_buy_cond = (df['ROC_126'] > 0) & (df['OBV_Crossover'] == 1)
    df['signal_momentum'] = pd.Series(np.where(momentum_buy_cond, 1, 0), index=df.index).shift(1).fillna(0)


    # --- 2. Fundamental Proxy Strategy ---

    # A) Value Proxy Strategy (Giá trị tương đối)
    # Buy: Giá thấp hơn 10% so với SMA 200 (quá rẻ) VÀ không phải là downtrend quá mạnh (ROC > -10%)
    value_buy_cond = (df['Adj Close'] < (df['SMA_200'] * 0.90)) & (df['ROC_126'] > -10)
    df['signal_value'] = pd.Series(np.where(value_buy_cond, 1, 0), index=df.index).shift(1).fillna(0)

    # B) Growth Proxy Strategy (Tăng trưởng)
    # Buy: ROC 126 (Tăng trưởng quá khứ) > 20% VÀ duy trì trên EMA 20 (Duy trì đà tăng trưởng)
    growth_buy_cond = (df['ROC_126'] > 20) & (df['Adj Close'] > df['EMA_20'])
    df['signal_growth'] = pd.Series(np.where(growth_buy_cond, 1, 0), index=df.index).shift(1).fillna(0)


    # --- 3. Existing SMA Cross / BB Reversion ---
    df['signal_sma'] = pd.Series(np.where(df['SMA_20'] > df['SMA_50'], 1, 0), index=df.index).shift(1).fillna(0)

    # BB mean reversion (State machine for entry/exit)
    buy_cond_bb = (df['Adj Close'] < df['BB_low']) & (df['RSI'] < 35)
    exit_cond_bb = df['Adj Close'] > df['BB_mid']

    position = 0
    bb_signals = []
    for i in range(len(df)):
        if position == 0 and buy_cond_bb.iloc[i]:
            position = 1
        elif position == 1 and exit_cond_bb.iloc[i]:
            position = 0
        bb_signals.append(position)

    df['signal_bb'] = pd.Series(bb_signals, index=df.index).shift(1).fillna(0)

    # Tín hiệu kết hợp (chỉ dành cho chạy thử nghiệm chính)
    df['signal_all_combined'] = pd.Series(np.where((df['signal_sma'] == 1) | (df['signal_bb'] == 1) | (df['signal_momentum'] == 1), 1, 0), index=df.index).shift(1).fillna(0)

    return df

# (Hàm backtest và plot_results được giữ nguyên)
# ============================================
# 6) Simple backtester
# ============================================
def backtest(df, signal_col='signal_any', fee=0.001, slippage=0.0, initial_capital=100000):
    df = df.copy()
    df['position'] = df[signal_col]

    df['strategy_return'] = df['position'].shift(1) * df['Daily_Return']
    df['strategy_return'] = df['strategy_return'].fillna(0)

    df['pos_diff'] = df['position'].diff().abs()
    cost_per_trade = fee + slippage
    df['strategy_return_after_fee'] = df['strategy_return'] - df['pos_diff'] * cost_per_trade

    df['equity'] = initial_capital * (1 + df['strategy_return_after_fee']).cumprod()

    df['buy_hold_return'] = df['Daily_Return']
    df['benchmark_equity'] = initial_capital * (1 + df['buy_hold_return']).cumprod()

    # === Performance Metrics ===
    total_days = (df.index[-1] - df.index[0]).days
    total_years = total_days / 365.25
    final_value = df['equity'].iloc[-1]

    cagr = (final_value / initial_capital) ** (1/total_years) - 1 if total_years > 0 else np.nan
    ann_vol = df['strategy_return_after_fee'].std() * np.sqrt(252)
    sharpe = (df['strategy_return_after_fee'].mean() * 252) / ann_vol if ann_vol > 0 else np.nan
    running_max = df['equity'].cummax()
    max_dd = (df['equity'] / running_max - 1).min()

    trades = []
    trade_return = 0
    in_trade = False

    for i in range(1, len(df)):
        if df['position'].iloc[i] == 1 and df['position'].iloc[i-1] == 0:
            in_trade = True
            trade_return = 0

        if in_trade and df['position'].iloc[i] == 1:
            trade_return += df['strategy_return_after_fee'].iloc[i]

        elif df['position'].iloc[i] == 0 and df['position'].iloc[i-1] == 1:
            trades.append(trade_return)
            in_trade = False

    wins = sum(1 for pnl in trades if pnl > 0)
    win_rate = wins / len(trades) if len(trades) > 0 else np.nan

    perf = {
        'initial_capital': initial_capital, 'final_value': final_value, 'cagr': cagr,
        'annual_vol': ann_vol, 'sharpe': sharpe, 'max_drawdown': max_dd,
        'win_rate': win_rate, 'n_trades': len(trades)
    }
    return df, perf

# ============================================
# 7) Plotting utility
# ============================================
def plot_results(df, perf, title='Strategy'):
    """Vẽ biểu đồ và hiển thị kết quả hiệu suất."""
    fig, axes = plt.subplots(3,1, figsize=(14,14), sharex=True,
                             gridspec_kw={'height_ratios':[2,1,1]})

    # 1. Biểu đồ Giá và Tín hiệu
    ax = axes[0]
    ax.plot(df['Adj Close'], label='Adj Close', lw=1.5, color='blue')
    ax.plot(df['SMA_20'], label='SMA 20', lw=1, color='orange', linestyle='--')
    ax.plot(df['SMA_50'], label='SMA 50', lw=1, color='red', linestyle='--')
    ax.plot(df['SMA_200'], label='SMA 200 (Value Proxy)', lw=1, color='gray', linestyle='-.')

    buys = df[(df['position']==1) & (df['position'].shift(1)==0)]
    sells = df[(df['position']==0) & (df['position'].shift(1)==1)]
    ax.scatter(buys.index, df.loc[buys.index,'Adj Close'], marker='^', color='green', s=70, label='Entry')
    ax.scatter(sells.index, df.loc[sells.index,'Adj Close'], marker='v', color='red', s=70, label='Exit')
    ax.set_title(title + ' - Price & Indicators', fontsize=16)
    ax.legend(loc='upper left', fontsize=10)
    ax.grid(True)

    # 2. ROC 126 & OBV (Momentum Visual)
    ax2 = axes[1].twinx()
    axes[1].plot(df['ROC_126'], label='ROC 126 (Price Momentum)', color='purple')
    axes[1].axhline(0, color='red', linestyle=':', lw=0.8)
    axes[1].set_title('Momentum Indicators (ROC & OBV)', fontsize=14)
    axes[1].legend(loc='upper left', fontsize=10)
    axes[1].grid(True)

    ax2.plot(df['OBV'], label='OBV', lw=1, color='blue', alpha=0.6)
    ax2.plot(df['OBV_SMA_20'], label='OBV SMA 20', lw=1.5, color='darkblue')
    ax2.legend(loc='upper right', fontsize=10)


    # 3. Equity curve
    axes[2].plot(df['equity'], label='Strategy Equity', lw=2, color='green')
    axes[2].plot(df['benchmark_equity'], label='Buy & Hold Benchmark', lw=1, color='red', linestyle=':')
    axes[2].set_ylabel('Equity (USD)', fontsize=12)
    axes[2].set_title('Equity Curve vs. Benchmark', fontsize=16)
    axes[2].legend(loc='upper left', fontsize=10)
    axes[2].grid(True)

    plt.tight_layout()
    plt.show()

    # Print perf
    print("\n" + "="*50)
    print("=== TÓM TẮT HIỆU SUẤT CHIẾN LƯỢC ===")
    print(f"Chiến lược: {title.split(' - ')[1]}")
    print(f"Ticker: {title.split(' - ')[0]}")
    print(f"Giai đoạn Backtest: {df.index.min().strftime('%Y-%m-%d')} đến {df.index.max().strftime('%Y-%m-%d')}")
    print("="*50)
    print(f"Vốn ban đầu: ${perf['initial_capital']:,.2f} | Giá trị cuối cùng: ${perf['final_value']:,.2f}")
    print("-" * 25)
    print(f"Lợi nhuận gộp hàng năm (CAGR): {perf['cagr'] * 100:.2f}%")
    print(f"Sharpe Ratio: {perf['sharpe']:.3f}")
    # Fix for KeyError: 'max_dd' - use 'max_drawdown' as defined in backtest()
    print(f"Giảm sút tối đa (Max Drawdown): {perf['max_drawdown'] * 100:.2f}%")
    print("-" * 25)
    print(f"Tổng số giao dịch đã đóng: {perf['n_trades']}")
    print(f"Tỷ lệ thắng (Win Rate): {perf['win_rate'] * 100:.2f}%")
    print("="*50)

# ============================================
# 8) LUỒNG THỰC THI CHÍNH (TESTING MULTIPLE STRATEGIES)
# ============================================
if __name__ == '__main__':
    ticker = 'META'
    start_date = '2015-01-01'

    print(f"--- BƯỚC 1: TẢI & LÀM SẠCH DỮ LIỆU cho {ticker} ---")
    df_cleaned = download_clean(ticker, start=start_date)

    if not df_cleaned.empty:
        print("\n--- BƯỚC 2: THÊM TẤT CẢ CHỈ BÁO KỸ THUẬT VÀ PROXY ---")
        df_ind = add_indicators(df_cleaned)

        if not df_ind.empty:
            df_sign = generate_signals(df_ind)

            # --- CHẠY THỬ NGHIỆM TỪNG CHIẾN LƯỢC RIÊNG LẺ ---

            # Thử nghiệm 1: Momentum (Price ROC + Volume OBV)
            print("\n=================================================")
            print("=== THỬ NGHIỆM CHIẾN LƯỢC 1: MOMENTUM (ROC+OBV) ===")
            print("=================================================")
            df_m, perf_m = backtest(df_sign, signal_col='signal_momentum', fee=0.0005, slippage=0.0001)
            plot_results(df_m, perf_m, title=f"{ticker} - Momentum (ROC 126 + OBV)")

            # Thử nghiệm 2: Fundamental Proxy - VALUE
            print("\n=================================================")
            print("=== THỬ NGHIỆM CHIẾN LƯỢC 2: VALUE PROXY (SMA 200) ===")
            print("=================================================")
            df_v, perf_v = backtest(df_sign, signal_col='signal_value', fee=0.0005, slippage=0.0001)
            plot_results(df_v, perf_v, title=f"{ticker} - Fundamental Proxy - Value (SMA 200)")

            # Thử nghiệm 3: Fundamental Proxy - GROWTH
            print("\n=================================================")
            print("=== THỬ NGHIỆN CHIẾN LƯỢC 3: GROWTH PROXY (ROC 126 > 20% + EMA 20) ===")
            print("=================================================")
            df_g, perf_g = backtest(df_sign, signal_col='signal_growth', fee=0.0005, slippage=0.0001)
            plot_results(df_g, perf_g, title=f"{ticker} - Fundamental Proxy - Growth")

            # Thử nghiệm 4: Tất cả kết hợp
            # print("\n=================================================")
            # print("=== THỬ NGHIỆM CHIẾN LƯỢC 4: TẤT CẢ KẾT HỢP ===")
            # print("=================================================")
            # df_c, perf_c = backtest(df_sign, signal_col='signal_all_combined', fee=0.0005, slippage=0.0001)
            # plot_results(df_c, perf_c, title=f"{ticker} - ALL Combined Strategy")

        else:
            print("Không đủ dữ liệu sau khi tính toán chỉ báo (cần ít nhất 200 ngày).")
    else:
        print(f"Quá trình phân tích bị dừng vì dữ liệu cho {ticker} rỗng hoặc lỗi.")

"""Chuẩn bị dữ liệu hồi quy"""

import yfinance as yf
import pandas as pd
import numpy as np
!pip install ta
import ta
from datetime import date
import warnings
from pandas.errors import SettingWithCopyWarning
warnings.filterwarnings('ignore', category=SettingWithCopyWarning)

# =========================================================================
# === HÀM TIỀN XỬ LÝ DỮ LIỆU & INDICATORS ==================================
# =========================================================================

def clean_financial_data(df: pd.DataFrame, ticker_symbol: str) -> pd.DataFrame:
    """Xử lý dữ liệu tài chính thô, bao gồm xử lý NaN, lỗi OHLC, và ngoại lai."""
    if df.empty:
        return pd.DataFrame()

    df = df.copy()
    price_cols = ['Open', 'High', 'Low', 'Adj Close', 'Volume']

    if isinstance(df.columns, pd.MultiIndex):
        df.columns = df.columns.get_level_values(0)
    if 'Close' in df.columns and 'Adj Close' not in df.columns:
        df = df.rename(columns={'Close': 'Adj Close'})

    df.index = pd.to_datetime(df.index)
    df = df.sort_index()
    df[price_cols] = df[price_cols].ffill().bfill()
    df.dropna(subset=['Adj Close'], inplace=True)
    df = df[df['Volume'] > 0]

    # Xử lý Outliers cho Daily Return
    df['Temp_Return'] = df['Adj Close'].pct_change()
    df.dropna(subset=['Temp_Return'], inplace=True)
    Q1_ret, Q3_ret = df['Temp_Return'].quantile([0.25, 0.75])
    IQR_ret = Q3_ret - Q1_ret
    lower_bound_ret = Q1_ret - 3.0 * IQR_ret
    upper_bound_ret = Q3_ret + 3.0 * IQR_ret
    df = df[(df['Temp_Return'] > lower_bound_ret) & (df['Temp_Return'] < upper_bound_ret)]
    df = df.drop(columns=['Temp_Return'])

    df['Daily_Return'] = df['Adj Close'].pct_change()
    df.dropna(subset=['Daily_Return'], inplace=True)

    return df

def download_clean(ticker: str, start: str, end: str = date.today().strftime('%Y-%m-%d'), interval: str = '1d') -> pd.DataFrame:
    """Tải dữ liệu từ yfinance và sau đó làm sạch."""
    try:
        df_raw = yf.download(ticker, start=start, end=end, interval=interval, progress=False)
        if df_raw.empty:
            raise ValueError("Không tìm thấy dữ liệu.")
    except Exception as e:
        print(f"[ERROR] LỖI TẢI DỮ LIỆU: {e}.")
        return pd.DataFrame()

    return clean_financial_data(df_raw, ticker)

def add_indicators(df, sma_short=20, sma_long=50, sma_very_long=200, bb_window=20, rsi_window=14):
    """Tính toán và thêm các chỉ báo kỹ thuật."""
    if df.empty:
        return pd.DataFrame()

    df = df.copy()
    df[f'SMA_{sma_short}'] = df['Adj Close'].rolling(sma_short).mean()
    df[f'SMA_{sma_long}'] = df['Adj Close'].rolling(sma_long).mean()
    df[f'SMA_{sma_very_long}'] = df['Adj Close'].rolling(sma_very_long).mean()
    df[f'EMA_{sma_short}'] = df['Adj Close'].ewm(span=sma_short, adjust=False).mean()

    bb = ta.volatility.BollingerBands(close=df['Adj Close'], window=bb_window, window_dev=2)
    df['BB_mid'] = bb.bollinger_mavg()
    df['BB_low'] = bb.bollinger_lband()
    df['RSI'] = ta.momentum.rsi(df['Adj Close'], window=rsi_window)

    roc_window = 126
    df[f'ROC_{roc_window}'] = ta.momentum.roc(df['Adj Close'], window=roc_window)
    df['OBV'] = ta.volume.on_balance_volume(df['Adj Close'], df['Volume'])
    obv_signal_window = 20
    df[f'OBV_SMA_{obv_signal_window}'] = df['OBV'].rolling(obv_signal_window).mean()

    df.dropna(inplace=True)
    return df

def generate_signals(df):
    """Tạo các tín hiệu giao dịch."""
    df = df.copy()
    df['signal_momentum'] = 0
    df['signal_value'] = 0
    df['signal_growth'] = 0

    df['OBV_Crossover'] = np.where(df['OBV'] > df['OBV_SMA_20'], 1, 0)
    momentum_buy_cond = (df['ROC_126'] > 0) & (df['OBV_Crossover'] == 1)
    df['signal_momentum'] = pd.Series(np.where(momentum_buy_cond, 1, 0), index=df.index).shift(1).fillna(0)

    value_buy_cond = (df['Adj Close'] < (df['SMA_200'] * 0.90)) & (df['ROC_126'] > -10)
    df['signal_value'] = pd.Series(np.where(value_buy_cond, 1, 0), index=df.index).shift(1).fillna(0)

    growth_buy_cond = (df['ROC_126'] > 20) & (df['Adj Close'] > df['EMA_20'])
    df['signal_growth'] = pd.Series(np.where(growth_buy_cond, 1, 0), index=df.index).shift(1).fillna(0)

    df['signal_sma'] = pd.Series(np.where(df['SMA_20'] > df['SMA_50'], 1, 0), index=df.index).shift(1).fillna(0)

    buy_cond_bb = (df['Adj Close'] < df['BB_low']) & (df['RSI'] < 35)
    exit_cond_bb = df['Adj Close'] > df['BB_mid']

    position = 0
    bb_signals = []
    for i in range(len(df)):
        if position == 0 and buy_cond_bb.iloc[i]:
            position = 1
        elif position == 1 and exit_cond_bb.iloc[i]:
            position = 0
        bb_signals.append(position)

    df['signal_bb'] = pd.Series(bb_signals, index=df.index).shift(1).fillna(0)
    df['signal_all_combined'] = pd.Series(np.where((df['signal_sma'] == 1) | (df['signal_bb'] == 1) | (df['signal_momentum'] == 1), 1, 0), index=df.index).shift(1).fillna(0)

    return df

import matplotlib.pyplot as plt
import statsmodels.api as sm
from scipy.stats.mstats import winsorize
from scipy import stats # Thêm thư viện stats
import numpy as np # Thêm thư viện numpy
import pandas as pd
# Giả định: Các hàm download_clean, add_indicators, generate_signals đã được định nghĩa.

ticker = 'META'
start_date = '2015-01-01'

print(f"--- BƯỚC 1: TẢI & LÀM SẠCH DỮ LIỆU cho {ticker} ---")
# Lưu ý: Hàm download_clean() cần phải được định nghĩa trước đó
df_cleaned = download_clean(ticker, start=start_date)

if not df_cleaned.empty:
    print("\n--- BƯỚC 2: THÊM TẤT CẢ CHỈ BÁO KỸ THUẬT VÀ PROXY ---")
    df_ind = add_indicators(df_cleaned)

    if not df_ind.empty:
        df_sign = generate_signals(df_ind)
        print("✅ Dữ liệu OHLC, indicators, và signals đã được tạo thành công.")

        # =======================================================
        # === BƯỚC 3: CHUẨN BỊ VÀ CHẠY HỒI QUY CƠ BẢN (OLS) ===
        # =======================================================
        reg_df = df_sign.copy()

        # Tính Log Returns
        reg_df['Log_Return'] = np.log(reg_df['Adj Close'] / reg_df['Adj Close'].shift(1))
        reg_df.dropna(subset=['Log_Return'], inplace=True)
        reg_df['Future_Log_Return'] = reg_df['Log_Return'].shift(-1)
        reg_df.dropna(subset=['Future_Log_Return'], inplace=True)

        # Định nghĩa Biến X cơ bản
        X_vars_basic = ['ROC_126', 'OBV_Crossover', 'signal_value', 'SMA_20', 'RSI']

        # Xử lý Outliers cho Biến X cơ bản
        for col in X_vars_basic:
            if reg_df[col].dtype in ['float64', 'int64'] and not (reg_df[col].isin([0, 1]).all()):
                reg_df[col] = winsorize(reg_df[col], limits=(0.01, 0.01))

        # --- CHẠY OLS CƠ BẢN ---
        Y_basic = reg_df['Future_Log_Return']
        X_basic = reg_df[X_vars_basic]
        X_basic = sm.add_constant(X_basic)

        ols_model_basic = sm.OLS(Y_basic, X_basic)
        results_basic = ols_model_basic.fit()

        print("\n" + "="*80)
        print("=== KẾT QUẢ HỒI QUY 1: OLS CƠ BẢN ===")
        print("="*80)
        print(results_basic.summary())
        print("="*80)

        # --- KIỂM TRA PHẦN DƯ CƠ BẢN ---
        residuals = results_basic.resid
        print("\n--- QQ Plot (Phần dư OLS cơ bản) ---")
        sm.qqplot(residuals, line='s')
        plt.title("QQ Plot of Residuals (Phần dư)")
        plt.show()

        shapiro_test = stats.shapiro(residuals)
        print("\n=== KẾT QUẢ KIỂM ĐỊNH SHAPIRO-WILK CHO PHẦN DƯ ===")
        print(f"Shapiro-Wilk Test Statistic: {shapiro_test.statistic:.4f}")
        print(f"P-value: {shapiro_test.pvalue:.4e}")

        if shapiro_test.pvalue < 0.05:
            print("❌ Bác bỏ H0. Phần dư KHÔNG phân phối chuẩn. Cần sử dụng các mô hình Robust hơn.")
        else:
            print("✅ Chấp nhận H0. Phần dư tuân theo phân phối chuẩn.")

        # =======================================================
        # === BƯỚC 4: THÊM BIẾN & NÂNG CẤP MÔ HÌNH (ROBUST & HC3) ===
        # =======================================================

        # --- BƯỚC NÂNG CẤP 1: THÊM BIẾN TRỄ (LAGGED RETURN) ---
        reg_df['Lagged_Log_Return'] = reg_df['Log_Return'].shift(1)
        reg_df.dropna(subset=['Lagged_Log_Return'], inplace=True)

        # Cập nhật danh sách biến X
        X_vars_new = X_vars_basic + ['Lagged_Log_Return']

        # Cập nhật lại X và Y sau khi thêm biến trễ (X_new và Y_new sẽ nhỏ hơn 1 hàng so với X_basic)
        X_new = reg_df[X_vars_new]
        Y_new = reg_df['Future_Log_Return']

        # Thêm hằng số
        X_new = sm.add_constant(X_new)

        # Xử lý giá trị vô hạn (nếu có do chia cho 0)
        X_new = X_new.replace([np.inf, -np.inf], np.nan).fillna(0.0)

        # 1. OLS với Sai số chuẩn Robust (HC3) - Khắc phục Heteroskedasticity
        print("\n" + "#"*80)
        print("=== KẾT QUẢ HỒI QUY 2: OLS VỚI SAI SỐ CHUẨN ROBUST (HC3) ===")
        print("#"*80)
        ols_hc3_model = sm.OLS(Y_new, X_new)
        # Sử dụng cov_type='HC3' để điều chỉnh Standard Errors và P-value
        ols_hc3_results = ols_hc3_model.fit(cov_type='HC3')
        print(ols_hc3_results.summary())

        # 2. Hồi quy Robust (RLM) - Khắc phục Non-Normality và Outliers
        print("\n" + "#"*80)
        print("=== KẾT QUẢ HỒI QUY 3: HỒI QUY ROBUST (RLM) ===")
        print("#"*80)
        # Sử dụng RLM (Robust Linear Model) với HuberT norm
        rlm_model = sm.RLM(Y_new, X_new, M=sm.robust.norms.HuberT())
        rlm_results = rlm_model.fit()
        print(rlm_results.summary())

        print("\nHoàn thành 3 mô hình hồi quy. Hãy so sánh kết quả HC3 và RLM!")

    else:
        print("Không đủ dữ liệu sau khi tính toán chỉ báo (cần ít nhất 200 ngày).")
else:
    print(f"Quá trình phân tích bị dừng vì dữ liệu cho {ticker} rỗng hoặc lỗi.")

import pandas as pd
import numpy as np
import statsmodels.api as sm

# Giả định: các biến results_basic, ols_hc3_results, rlm_results đã được tính toán
# và chứa kết quả từ OLS cơ bản, OLS/HC3, và RLM.

def extract_comparison_data(results, model_name):
    """Trích xuất các thông số chính (Coef, P-value) từ kết quả hồi quy."""

    # Lấy các biến chính (Hệ số và P-value)
    summary = pd.DataFrame({
        f'Coef_{model_name}': results.params,
        f'P-value_{model_name}': results.pvalues
    })

    # Lấy R-squared (hoặc Pseudo R-squared cho RLM)
    if model_name == 'RLM':
        # RLM sử dụng Pseudo R-squared
        r_sq = results.prsquared if hasattr(results, 'prsquared') else np.nan
        summary.loc['Pseudo R-sq', f'Coef_{model_name}'] = r_sq
        summary.loc['Pseudo R-sq', f'P-value_{model_name}'] = np.nan
    else:
        # OLS sử dụng R-squared và P-value của F-statistic
        r_sq = results.rsquared
        f_pvalue = results.f_pvalue
        summary.loc['R-squared', f'Coef_{model_name}'] = r_sq
        summary.loc['R-squared', f'P-value_{model_name}'] = f_pvalue

    return summary.copy()

# Trích xuất dữ liệu từ 3 mô hình
df_ols = extract_comparison_data(results_basic, 'OLS')
df_hc3 = extract_comparison_data(ols_hc3_results, 'OLS_HC3')
df_rlm = extract_comparison_data(rlm_results, 'RLM')

# Kết hợp các kết quả
comparison_df = df_ols.join(df_hc3, how='outer').join(df_rlm, how='outer')

# Chỉ giữ lại các biến quan trọng: const, Lagged Return, ROC, RSI và R-squared
vars_to_keep = ['const', 'Lagged_Log_Return', 'ROC_126', 'RSI', 'R-squared', 'Pseudo R-sq']
comparison_df = comparison_df.loc[comparison_df.index.isin(vars_to_keep)]

# Định dạng hiển thị cho trực quan hơn
pd.options.display.float_format = '{:.6f}'.format
comparison_df.index.name = 'Variable'

print("\n" + "="*120)
print("=== BẢNG TỔNG HỢP SO SÁNH KẾT QUẢ HỒI QUY (Tập trung vào Robustness) ===")
print("="*120)
print(comparison_df.sort_index(ascending=False).to_string())
print("="*120)

# --- PHÂN TÍCH LOGIC TRỰC QUAN ---
print("\n### PHÂN TÍCH LOGIC TRỰC QUAN ###")
print("-" * 30)

# Lấy P-value của Lagged Return trong mô hình HC3 (đáng tin cậy nhất)
p_value_lagged = comparison_df.loc['Lagged_Log_Return', 'P-value_OLS_HC3']

print(f"1. R-squared (Sức mạnh giải thích): {comparison_df.loc['R-squared', 'Coef_OLS_HC3']:.6f}")
print("   -> Giá trị R-squared còn rất thấp. Mô hình cần thêm các biến mạnh hơn.")

if p_value_lagged < 0.05:
    print(f"\n2. Lagged Log Return (Lợi nhuận t-1):")
    print(f"   -> P-value_HC3 = {p_value_lagged:.6f}. Biến này **CÓ Ý NGHĨA** thống kê (Autocorrelation).")

    # So sánh độ lớn hệ số
    coef_ols = comparison_df.loc['Lagged_Log_Return', 'Coef_OLS']
    coef_rlm = comparison_df.loc['Lagged_Log_Return', 'Coef_RLM']

    print(f"   -> Hệ số OLS ({coef_ols:.6f}) và RLM ({coef_rlm:.6f}) có độ lớn tương đồng.")
    if abs(coef_ols - coef_rlm) > 0.0001:
        print("      CẢNH BÁO: RLM và OLS có sự khác biệt nhỏ về hệ số. Hệ số RLM thường đáng tin cậy hơn.")
    else:
        print("      Hệ số vững chắc (Robust).")
else:
    print("\n2. Lagged Log Return (Lợi nhuận t-1): KHÔNG CÓ Ý NGHĨA thống kê.")

# Kiểm tra RSI trong mô hình HC3 (Vì P-value ban đầu gần 0.05)
p_value_rsi = comparison_df.loc['RSI', 'P-value_OLS_HC3']

if p_value_rsi < 0.05:
     print(f"\n3. RSI: CÓ Ý NGHĨA thống kê với P-value_HC3 = {p_value_rsi:.6f}.")
else:
     print(f"\n3. RSI: KHÔNG CÓ Ý NGHĨA thống kê với P-value_HC3 = {p_value_rsi:.6f}.")

# So sánh P-value của các biến khác (ROC_126)
p_value_roc = comparison_df.loc['ROC_126', 'P-value_OLS_HC3']
if p_value_roc < 0.05:
     print(f"   -> ROC_126: CÓ Ý NGHĨA.")
else:
     print(f"   -> ROC_126: KHÔNG CÓ Ý NGHĨA (P-value_HC3 = {p_value_roc:.6f}).")

# --- BƯỚC NÂNG CẤP 3: THÊM TƯƠNG TÁC VÀ YẾU TỐ RỦI RO ---
# Yếu tố rủi ro: Volatility (Biến động)
reg_df['Volatility'] = reg_df['Log_Return'].rolling(window=20).std().shift(1) # Volatility của ngày hôm qua

# Biến tương tác: Chiến lược chỉ hoạt động khi cả hai điều kiện thỏa mãn
# Tương tác RSI và Momentum: ROC * RSI (Tín hiệu Momentum chỉ mạnh khi RSI không quá cao/thấp)
reg_df['ROC_x_RSI'] = reg_df['ROC_126'] * reg_df['RSI']

# Cập nhật và tinh chỉnh X_vars cuối cùng
# Loại bỏ SMA_20 (vì nó có thể gây đa cộng tuyến với ROC)
X_vars_final = ['Lagged_Log_Return', 'Volatility', 'ROC_126', 'RSI', 'ROC_x_RSI']

reg_df.dropna(subset=X_vars_final, inplace=True)

Y_final = reg_df['Future_Log_Return']
X_final = reg_df[X_vars_final]

# Chạy lại mô hình Robust HC3
X_final = sm.add_constant(X_final)
ols_hc3_model_final = sm.OLS(Y_final, X_final)
final_results = ols_hc3_model_final.fit(cov_type='HC3')

print("\n" + "#"*80)
print("=== KẾT QUẢ CUỐI CÙNG: MÔ HÌNH HC3 + TƯƠNG TÁC VÀ VOLATILITY ===")
print("#"*80)
print(final_results.summary())

# Giả định X_final là DataFrame chứa các biến độc lập của mô hình cuối cùng

print("\n" + "*"*80)
print("=== BƯỚC KHẮC PHỤC: KIỂM TRA MA TRẬN TƯƠNG QUAN ===")
print("*"*80)

# Loại bỏ cột hằng số ('const') khỏi X_final để tính tương quan
X_for_corr = X_final.drop(columns=['const'], errors='ignore')

# Tính ma trận tương quan
correlation_matrix = X_for_corr.corr().round(4)
print(correlation_matrix.to_string())

# Trực quan hóa ma trận tương quan (Tùy chọn)
import seaborn as sns
plt.figure(figsize=(8, 6))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f", linewidths=.5)
plt.title('Correlation Matrix of Final Predictors')
plt.show()

print("\n--- PHÂN TÍCH VÀ QUYẾT ĐỊNH ---")
print("Hãy tìm các cặp biến có giá trị tuyệt đối > 0.8 và loại bỏ một trong hai.")

# Sau khi xác định biến có tương quan cao (ví dụ: ROC_126 và ROC_x_RSI)
# Bạn cần loại bỏ biến gây ra đa cộng tuyến và CHẠY LẠI MÔ HÌNH.

# --- BƯỚC KHẮC PHỤC CUỐI CÙNG: LOẠI BỎ ROC_126 VÀ CHẠY LẠI ---

# Cập nhật danh sách biến X (LOẠI BỎ ROC_126)
X_vars_final_clean = ['Lagged_Log_Return', 'Volatility', 'RSI', 'ROC_x_RSI']

# Xử lý các hàng bị NaN do Lagged_Log_Return hoặc Volatility (đã xảy ra ở bước trước)
reg_df.dropna(subset=X_vars_final_clean, inplace=True)

Y_final = reg_df['Future_Log_Return']
X_final_clean = reg_df[X_vars_final_clean]

# Chạy lại mô hình Robust HC3
X_final_clean = sm.add_constant(X_final_clean)
ols_hc3_model_final_clean = sm.OLS(Y_final, X_final_clean)

print("\n" + "#"*80)
print("=== KẾT QUẢ CUỐI CÙNG SAU KHI KHẮC PHỤC ĐA CỘNG TUYẾN (HC3) ===")
print("#"*80)

# Sử dụng cov_type='HC3'
final_results_clean = ols_hc3_model_final_clean.fit(cov_type='HC3')
print(final_results_clean.summary())
# --- BƯỚC KHẮC PHỤC CUỐI CÙNG LẦN 2: LOẠI BỎ RSI ---

# Cập nhật danh sách biến X (LOẠI BỎ RSI)
# Giữ Lagged_Log_Return, Volatility, và ROC_x_RSI
X_vars_final_stable = ['Lagged_Log_Return', 'Volatility', 'ROC_x_RSI']

# Giả định reg_df đã chứa dữ liệu sạch và các biến mới

Y_final = reg_df['Future_Log_Return']
X_final_stable = reg_df[X_vars_final_stable]

# Chạy lại mô hình Robust HC3
X_final_stable = sm.add_constant(X_final_stable)
ols_hc3_model_final_stable = sm.OLS(Y_final, X_final_stable)

print("\n" + "#"*80)
print("=== KẾT QUẢ CUỐI CÙNG: KHẮC PHỤC ĐA CỘNG TUYẾN (HC3, Chỉ giữ Tương tác) ===")
print("#"*80)

# Sử dụng cov_type='HC3'
final_results_stable = ols_hc3_model_final_stable.fit(cov_type='HC3')
print(final_results_stable.summary())

"""NHẬN THẤY HỒI QUY KHÔNG ĐỦ MẠNH ĐỂ PHÂN TÍCH
NÊN DÙNG CÁC MÔ HÌNH KHÁC

1 MÔ HÌNH PHI TUYẾN TÍNH (NEURAL NETWORKS)
"""

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
from sklearn.metrics import accuracy_score, classification_report
import warnings

# --- TÁI TẠO DỮ LIỆU ĐẦU VÀO ---
# Giả định: reg_df, Log_Return, Lagged_Log_Return, Volatility, ROC_x_RSI đã có

# 1. Tính Future 5-Day Log Return (Sử dụng tổng 5 ngày Log_Return tiếp theo)
WINDOW = 5
reg_df['Future_5D_Log_Return'] = reg_df['Log_Return'].rolling(window=WINDOW).sum().shift(-WINDOW)
reg_df.dropna(subset=['Future_5D_Log_Return'], inplace=True)

# 2. Tạo Target phân loại 5-Day
reg_df['Target_5D'] = np.where(reg_df['Future_5D_Log_Return'] >= 0, 1, 0)

# 3. Chuẩn bị X và Y
X_vars_final = ['Lagged_Log_Return', 'Volatility', 'ROC_x_RSI']
X = reg_df[X_vars_final].dropna()
Y = reg_df.loc[X.index, 'Target_5D']

# Lọc X và Y lần cuối để đảm bảo cùng chỉ mục
X = X.loc[Y.index]

# Chia và Chuẩn hóa
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, shuffle=False)
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# --- B. Code Chạy Neural Network (Kiến trúc đã tối ưu) ---

model_5d = Sequential()
model_5d.add(Dense(units=10, activation='relu', input_dim=X_train_scaled.shape[1]))
model_5d.add(Dense(units=5, activation='relu'))
model_5d.add(Dense(units=1, activation='sigmoid')) # Output: Xác suất tăng/giảm

model_5d.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# Huấn luyện mô hình
history_5d = model_5d.fit(
    X_train_scaled, Y_train,
    epochs=100, # Tăng epochs để tìm mối quan hệ dự đoán phức tạp hơn
    batch_size=32,
    validation_data=(X_test_scaled, Y_test),
    verbose=0
)

# --- C. Đánh giá Kết quả 5 Ngày ---
Y_pred_proba_5d = model_5d.predict(X_test_scaled)
Y_pred_5d = (Y_pred_proba_5d > 0.5).astype(int)

print("\n" + "="*80)
print("=== KẾT QUẢ NN TINH CHỈNH: DỰ ĐOÁN 5 NGÀY ===")
print("="*80)
test_accuracy_5d = accuracy_score(Y_test, Y_pred_5d)
baseline_accuracy_5d = Y_train.value_counts(normalize=True).max()

print(f"Accuracy chung (5 Ngày): {test_accuracy_5d*100:.2f}%")
print(f"Baseline Accuracy (Lớp phổ biến): {baseline_accuracy_5d*100:.2f}%")
print("\nClassification Report (5 Ngày):")
print(classification_report(Y_test, Y_pred_5d, target_names=['Giảm (0)', 'Tăng (1)']))
print("="*80)

"""KẾT QUẢ CHO RA MÔ HÌNH NEURAL NETWORK KHÔNG HIỆU QUẢ

ARIMA
"""

import pandas as pd
import numpy as np
# Ensure pmdarima is installed
!pip install pmdarima
from pmdarima import auto_arima
import statsmodels.api as sm
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error
from math import sqrt
import warnings
import matplotlib.pyplot as plt # Added import for matplotlib.pyplot

# --- Cài đặt thư viện cần thiết ---
# Bạn cần chạy: !pip install pmdarima

# --- Tái tạo dữ liệu chuỗi thời gian ---
# Giả định: reg_df và cột 'Log_Return' đã được tính toán.
# ARIMA chỉ cần Log_Return làm biến đầu vào duy nhất.

# Xử lý các hàng có NaN
ts_data = reg_df['Log_Return'].dropna()

# --- BƯỚC 1: CHIA DỮ LIỆU HUẤN LUYỆN VÀ KIỂM THỬ ---
# ARIMA yêu cầu chia theo thời gian (shuffle=False)
train_size = int(len(ts_data) * 0.8)
train_ts = ts_data[:train_size]
test_ts = ts_data[train_size:]

print(f"Kích thước Training Set: {len(train_ts)} ngày")
print(f"Kích thước Testing Set: {len(test_ts)} ngày")

# --- BƯỚC 2: TÌM KIẾM THAM SỐ ARIMA TỐI ƯU (p, d, q) ---
# Sử dụng auto_arima để tự động chọn các tham số mô hình tốt nhất
# dựa trên tiêu chí AIC (Akaike Information Criterion)

# d=0 vì Log Returns đã Stationary
# max_p và max_q giới hạn việc tìm kiếm
print("\n--- Bắt đầu tìm kiếm tham số ARIMA tối ưu ---")

# Suppress warnings for clearer output
warnings.filterwarnings("ignore")

try:
    arima_model = auto_arima(
        train_ts,
        start_p=1, start_q=1,
        max_p=3, max_q=3,
        m=1, # Không phải mùa vụ (Non-seasonal)
        d=0, # Log Returns đã là Stationary
        D=0,
        trace=False, # Không in ra từng bước thử nghiệm
        error_action='ignore',
        suppress_warnings=True,
        stepwise=True, # Sử dụng tìm kiếm Stepwise nhanh hơn
        seasonal=False
    )

    print(f"✅ Mô hình ARIMA tối ưu đã chọn: {arima_model.order}")
    print(arima_model.summary())

except Exception as e:
    print(f"LỖI TÌM KIẾM ARIMA: {e}")
    print("Sử dụng ARIMA(1, 0, 1) mặc định.")
    arima_model = sm.tsa.ARIMA(train_ts, order=(1, 0, 1)).fit()


# --- BƯỚC 3: DỰ ĐOÁN VÀ ĐÁNH GIÁ ---

# Dự đoán trên tập kiểm thử
forecast = arima_model.predict(n_periods=len(test_ts))
forecast_series = pd.Series(forecast.values, index=test_ts.index) # Fixed: Use .values to correctly align index

# Đánh giá bằng RMSE (Root Mean Squared Error)
rmse = sqrt(mean_squared_error(test_ts, forecast_series))

print("\n" + "="*60)
print("=== ĐÁNH GIÁ MÔ HÌNH ARIMA ===")
print(f"RMSE (Root Mean Squared Error) trên Test Set: {rmse:.6f}")
print(f"Độ lệch chuẩn (Std Dev) của Log Return (Test Set): {test_ts.std():.6f}")
print("="*60)

# --- BƯỚC 4: TRỰC QUAN HÓA (Tùy chọn) ---
plt.figure(figsize=(12, 6))
plt.plot(test_ts, label='Giá trị Thực tế (Log Return)', color='blue', alpha=0.6)
plt.plot(forecast_series, label='Dự đoán ARIMA', color='red', linestyle='--')
plt.title('ARIMA Forecast vs. Actual Log Returns (Test Set)')
plt.legend()
plt.grid(True)
plt.show()

# --- Kết luận Sức mạnh Dự đoán ---
if rmse < test_ts.std():
    print("✅ Mô hình ARIMA có hiệu suất tốt hơn so với dự đoán giá trị trung bình.")
else:
    print("❌ Mô hình ARIMA không cải thiện đáng kể so với dự đoán trung bình (hiệu suất yếu).")

"""phân tích momentum

"""

import pandas as pd
import numpy as np
import yfinance as yf

def calculate_mfi_manual(
    df: pd.DataFrame,
    window: int = 14
) -> pd.Series:
    """
    Tính toán chỉ số Dòng tiền (Money Flow Index - MFI) thủ công.

    Args:
        df (pd.DataFrame): DataFrame chứa dữ liệu OHLCV (High, Low, Close, Volume).
        window (int): Số kỳ (period) để tính toán MFI.

    Returns:
        pd.Series: Chuỗi giá trị MFI.
    """
    if 'High' not in df.columns or 'Low' not in df.columns or 'Close' not in df.columns or 'Volume' not in df.columns:
        raise ValueError("DataFrame phải chứa các cột 'High', 'Low', 'Close' và 'Volume'.")

    # 1. Tính Giá Điển hình (Typical Price - TP)
    typical_prices = (df['High'] + df['Low'] + df['Close']) / 3

    # 2. Tính Dòng tiền Thô (Raw Money Flow - RMF)
    raw_money_flow = typical_prices * df['Volume']

    # 3. Phân loại và Tính tổng Dòng tiền Dương (PMF) / Âm (NMF)

    # Xác định ngày mà TP tăng (Dương)
    is_positive = typical_prices > typical_prices.shift(1)

    # Dòng tiền Dương: Chỉ giữ RMF khi TP tăng, sau đó tính tổng trong window
    positive_money_flow = raw_money_flow.where(is_positive, 0).rolling(window=window).sum()

    # Dòng tiền Âm: Chỉ giữ RMF khi TP giảm, sau đó tính tổng trong window
    # Lưu ý: Cần đảm bảo rằng raw_money_flow được gán bằng 0 nếu TP không giảm (bao gồm cả khi TP bằng TP.shift(1))
    negative_money_flow = raw_money_flow.where(typical_prices < typical_prices.shift(1), 0).rolling(window=window).sum()

    # Xử lý trường hợp NMF bằng 0 để tránh chia cho zero hoặc NaN
    # Thêm một lượng nhỏ (epsilon) vào mẫu số, hoặc dùng np.divide
    negative_money_flow = negative_money_flow.replace(0, np.nan)

    # 4. Tính Tỷ lệ Dòng tiền (Money Ratio - MR)
    money_ratio = positive_money_flow / negative_money_flow

    # 5. Tính Chỉ số MFI (Chuẩn hóa từ 0 đến 100)
    mfi = 100 - (100 / (1 + money_ratio))

    return mfi

# ==============================================================================
# VÍ DỤ CHẠY THỬ
# ==============================================================================
if __name__ == '__main__':
    TICKER = 'TSLA'
    df = yf.download(TICKER, start='2023-01-01', end='2025-10-10',progress=False)

    # Kiểm tra và điều chỉnh tên cột nếu cần (yfinance thường trả về Adj Close)
    if 'Adj Close' in df.columns:
        df['Close'] = df['Adj Close']

    # Tính MFI thủ công với window = 14
    mfi_values = calculate_mfi_manual(df, window=14)

    # In kết quả
    df['MFI_Manual'] = mfi_values

    print(f"--- MFI (Money Flow Index) Thủ công cho {TICKER} (Window=14) ---")
    print(df[['Close', 'Volume', 'MFI_Manual']].tail(10).round(2))

    # Tình trạng MFI gần nhất
    latest_mfi = mfi_values.iloc[-1].item() # Extract the scalar value
    status = ""
    if latest_mfi >= 80:
        status = "QUÁ MUA (Overbought - Rủi ro đảo chiều giảm)"
    elif latest_mfi <= 20:
        status = "QUÁ BÁN (Oversold - Rủi ro đảo chiều tăng)"
    else:
        status = "Trung tính"

    print("\n" + "="*50)
    print(f"| MFI hiện tại: {latest_mfi:.2f}")
    print(f"| Tình trạng: {status}")
    print("="*50)

import pandas as pd
import numpy as np
import yfinance as yf

def calculate_williams_r_manual(
    df: pd.DataFrame,
    window: int = 14
) -> pd.Series:

    if 'High' not in df.columns or 'Low' not in df.columns or 'Close' not in df.columns:
        raise ValueError("DataFrame phải chứa các cột 'High', 'Low' và 'Close'.")

    prices_high = df['High']
    prices_low = df['Low']
    prices_close = df['Close']

    # 1. Xác định Giá Cao nhất và Thấp nhất trong phạm vi N kỳ
    highest_high = prices_high.rolling(window=window).max()
    lowest_low = prices_low.rolling(window=window).min()

    # 2. Tính Phạm vi Tổng thể
    range_total = highest_high - lowest_low

    # Xử lý trường hợp range_total bằng 0 (khi giá High = Low)
    range_total = range_total.replace(0, np.nan)

    # 3. Tính Williams %R
    # (Cao nhất trong N kỳ - Giá Đóng cửa) / (Phạm vi Tổng thể) * (-100)
    percent_r = -((highest_high - prices_close) / range_total) * 100

    return percent_r

# ==============================================================================
# VÍ DỤ CHẠY THỬ
# ==============================================================================
if __name__ == '__main__':
    TICKER = 'TSLA'
    df = yf.download(TICKER, start='2023-01-01',end='2025-10-10', progress=False)

    # Đảm bảo cột Close là giá đã điều chỉnh nếu cần
    if 'Adj Close' in df.columns:
        df['Close'] = df['Adj Close']

    williams_r_values = calculate_williams_r_manual(df, window=14)

    # In kết quả
    df['Williams_%R'] = williams_r_values

    print(f"--- Williams %R cho {TICKER} (Window=14) ---")
    print(df[['Close', 'Williams_%R']].tail(10).round(2))

    # Tình trạng %R gần nhất
    latest_r = williams_r_values.iloc[-1]
    status = ""
    if latest_r.item() >= -20:
        status = "QUÁ MUA (Overbought: Giá gần đỉnh 14 kỳ)"
    elif latest_r.item() <= -80:
        status = "QUÁ BÁN (Oversold: Giá gần đáy 14 kỳ)"
    else:
        status = "Trung tính"

    print("\n" + "="*50)
    print(f"| Williams %R hiện tại: {latest_r.item():.2f}")
    print(f"| Tình trạng: {status}")
    print("="*50)

import pandas as pd
import numpy as np
import yfinance as yf

def calculate_cci_manual(
    df: pd.DataFrame,
    window: int = 20,
    constant: float = 0.015
) -> pd.Series:
    """
    Tính toán Chỉ số Kênh Hàng hóa (CCI) thủ công.

    Args:
        df (pd.DataFrame): DataFrame chứa dữ liệu OHLC (High, Low, Close).
        window (int): Số kỳ (period) để tính toán CCI (mặc định là 20).
        constant (float): Hằng số được sử dụng để chuẩn hóa (mặc định là 0.015).

    Returns:
        pd.Series: Chuỗi giá trị CCI.
    """
    if 'High' not in df.columns or 'Low' not in df.columns or 'Close' not in df.columns:
        raise ValueError("DataFrame phải chứa các cột 'High', 'Low' và 'Close'.")

    prices_high = df['High']
    prices_low = df['Low']
    prices_close = df['Close']

    # 1. Tính Giá Điển hình (TP)
    typical_prices = (prices_high + prices_low + prices_close) / 3

    # 2. Tính Đường Trung bình Động (SMA) của TP
    sma_typical_prices = typical_prices.rolling(window=window).mean()

    # 3. Tính Độ Lệch Trung bình (MD)
    mean_deviation = (
        (typical_prices - sma_typical_prices).abs().rolling(window=window).mean()
    )

    # 4. Tính Chỉ số CCI
    #  mean_deviation bằng 0 có thể xảy ra khi giá không đổi trong 20 ngày.
    # Chúng ta sử dụng np.where để xử lý trường hợp chia cho 0, trả về 0 nếu MD = 0,
    # mặc dù theo lý thuyết thì MD không bao giờ nên bằng 0.

    # Tính mẫu số
    denominator = constant * mean_deviation

    # Sử dụng np.divide để xử lý phép chia an toàn
    cci_values = np.divide(
        (typical_prices - sma_typical_prices),
        denominator,
        out=np.zeros_like(typical_prices, dtype=float), # Trả về 0 nếu chia cho 0
        where=denominator != 0 # Chỉ chia khi mẫu số khác 0
    )

    # Các hàng NaN ở đầu (do rolling) vẫn tồn tại và sẽ được xử lý ở phần gọi hàm.
    return pd.Series(cci_values, index=df.index)

# ==============================================================================
# VÍ DỤ CHẠY THỬ
# ==============================================================================
if __name__ == '__main__':
    TICKER = 'TSLA'
    # Tải dữ liệu, đặt auto_adjust=False để giữ Adj Close
    df_raw = yf.download(TICKER, start='2023-01-01',end='2025-10-10', progress=False, auto_adjust=False)

    # Làm phẳng cột nếu yfinance trả về MultiIndex
    if isinstance(df_raw.columns, pd.MultiIndex):
        df_raw.columns = df_raw.columns.droplevel(1)

    # Đảm bảo cột Close là giá đã điều chỉnh
    if 'Adj Close' in df_raw.columns:
        df_raw['Close'] = df_raw['Adj Close']

    # Tính CCI thủ công với window = 20
    cci_values = calculate_cci_manual(df_raw, window=20)

    # Loại bỏ NaN để đảm bảo kết quả là số hợp lệ
    df_raw['CCI_Manual'] = cci_values
    df_cleaned = df_raw.dropna() # Loại bỏ 19 hàng NaN đầu tiên

    print(f"--- CCI (Commodity Channel Index) Thủ công cho {TICKER} (Window=20) ---")
    print(df_cleaned[['Close', 'CCI_Manual']].tail(10).round(2))

    # Tình trạng CCI gần nhất
    latest_cci = df_cleaned['CCI_Manual'].iloc[-1]

    status = ""
    # Kiểm tra giá trị CCI
    if latest_cci >= 100:
        status = "QUÁ MUA (> 100) - Xu hướng tăng rất mạnh"
    elif latest_cci <= -100:
        status = "QUÁ BÁN (< -100) - Xu hướng giảm rất mạnh"
    else:
        status = "Trung tính"

    print("\n" + "="*70)
    print(f"| CCI hiện tại: {latest_cci:.2f}")
    print(f"| Tình trạng: {status}")
    print("="*70)

import pandas as pd
import numpy as np
import yfinance as yf

def calculate_rvi_custom(
    df: pd.DataFrame,
    window: int = 10
) -> pd.Series:
    """
    Tính toán Chỉ số Sức mạnh Tương đối (RVI) - phiên bản TÙY CHỈNH dựa trên
    tỷ lệ tổng lực mua so với tổng lực bán (có cân nhắc khối lượng).

    LƯU Ý: Đây không phải công thức RVI tiêu chuẩn được công nhận rộng rãi.
    """
    if 'Open' not in df.columns or 'Close' not in df.columns or 'Volume' not in df.columns:
        raise ValueError("DataFrame phải chứa các cột 'Open', 'Close' và 'Volume'.")

    prices_open = df['Open']
    prices_close = df['Close']
    volumes = df['Volume']

    close_open_diff = prices_close - prices_open

    # Lực mua (tổng độ tăng)
    up_close_open = close_open_diff.where(close_open_diff > 0, 0)
    # Lực bán (tổng độ giảm, giá trị tuyệt đối)
    down_close_open = -close_open_diff.where(close_open_diff < 0, 0)

    # Tính tổng lực (không nhân khối lượng - lỗi ban đầu trong code gốc)
    # Dựa trên công thức gốc: (up_sum / volume_sum) / (down_sum / volume_sum)
    # Về toán học: (up_sum / down_sum)
    up_sum = up_close_open.rolling(window=window).sum()
    down_sum = down_close_open.rolling(window=window).sum()

    # Xử lý LỖI CHIA CHO ZERO: Tránh chia cho zero nếu không có lực bán trong window
    # Thay thế 0 bằng np.nan để loại bỏ các hàng này, hoặc thêm một epsilon nhỏ
    down_sum_safe = down_sum.replace(0, np.nan)

    # Tính tỷ lệ lực mua/bán
    rvi_custom = up_sum / down_sum_safe

    return rvi_custom

# ==============================================================================
# VÍ DỤ CHẠY THỬ
# ==============================================================================
if __name__ == '__main__':
    TICKER = 'MSFT'
    df_raw = yf.download(TICKER, start='2024-01-01', end='2025-10-10',progress=False)

    # Làm phẳng cột nếu yfinance trả về MultiIndex
    if isinstance(df_raw.columns, pd.MultiIndex):
        df_raw.columns = df_raw.columns.droplevel(1)

    # Tính RVI tùy chỉnh với window = 10
    rvi_values = calculate_rvi_custom(df_raw, window=10)

    # In kết quả
    df_raw['RVI_Custom'] = rvi_values

    # Loại bỏ hàng NaN để xem kết quả hợp lệ
    df_cleaned = df_raw.dropna(subset=['RVI_Custom'])

    print(f"--- RVI (Tùy chỉnh) cho {TICKER} (Window=10) ---")
    print(df_cleaned[['Open', 'Close', 'RVI_Custom']].tail(10).round(2))

    # Tình trạng RVI gần nhất
    latest_rvi = df_cleaned['RVI_Custom'].iloc[-1]
    status = ""

    # Thường RVI > 1 là mua, < 1 là bán
    if latest_rvi > 1.0:
        status = "ÁP LỰC MUA (Bullish: Lực mua > Lực bán)"
    elif latest_rvi < 1.0:
        status = "ÁP LỰC BÁN (Bearish: Lực bán > Lực mua)"
    else:
        status = "Cân bằng"

    print("\n" + "="*70)
    print(f"| RVI hiện tại: {latest_rvi:.2f}")
    print(f"| Tình trạng: {status}")
    print("="*70)