# -*- coding: utf-8 -*-
"""Copy of momentum

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1d1PQb_tA7_uVMnvgsj5cMA03Kgdtt15i
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
!pip install financetoolkit

# Giữ nguyên các import bên ngoài (Giả sử các hàm này đã được implement đúng)
from financetoolkit.technicals.overlap_model import (
    get_exponential_moving_average,
    get_moving_average,
)


def get_money_flow_index(
    prices_high: pd.Series,
    prices_low: pd.Series,
    prices_close: pd.Series,
    volumes: pd.Series,
    window: int = 14,
) -> pd.Series:
    """
    Calculate the Money Flow Index (MFI) indicator for a given price series.

    Args:
        prices_high (pd.Series): Series of high prices.
        prices_low (pd.Series): Series of low prices.
        prices_close (pd.Series): Series of closing prices.
        volumes (pd.Series): Series of trading volumes.
        window (int): Number of periods for MFI calculation (Default: 14).

    Returns:
        pd.Series: MFI values.
    """
    typical_prices = (prices_high + prices_low + prices_close) / 3
    raw_money_flow = typical_prices * volumes

    positive_money_flow = (
        raw_money_flow.where(typical_prices > typical_prices.shift(1), 0)
        .rolling(window=window,min_periods=window)
        .sum()
    )
    negative_money_flow = (
        raw_money_flow.where(typical_prices < typical_prices.shift(1), 0)
        .rolling(window=window,min_periods=window)
        .sum()
    )

    # --- Sửa lỗi chia cho 0 ---
    # Nếu negative_money_flow = 0, money_ratio sẽ vô hạn, MFI = 100 (xu hướng tăng mạnh)
    # np.divide để xử lý cảnh báo và thay thế bằng np.inf
    money_ratio = np.divide(
        positive_money_flow.values,
        negative_money_flow.values,
        out=np.full(positive_money_flow, np.inf, dtype=float),
        where=negative_money_flow.values != 0,
    )

    money_ratio = pd.Series(money_ratio, index=prices_close.index)
    # Giới hạn giá trị MFI Max = 100
    mfi = 100 - (100 / (1 + money_ratio))

    return mfi.astype(float)


def get_williams_percent_r(
    prices_high: pd.Series, prices_low: pd.Series, prices_close: pd.Series, window: int = 14
) -> pd.Series:
    """
    Calculate the Williams %R indicator for a given price series.

    Args:
        prices_high (pd.Series): Series of high prices.
        prices_low (pd.Series): Series of low prices.
        prices_close (pd.Series): Series of closing prices.
        window (int): Number of periods for %R calculation (Default: 14).

    Returns:
        pd.Series: Williams %R values.
    """
    highest_high = prices_high.rolling(window=window).max()
    lowest_low = prices_low.rolling(window=window).min()
    divisor = highest_high - lowest_low

    # xử lý chia 0, nếu biên độ bằng 0 thị trường đi ngang quá mạnh
    percent_r_raw = np.divide(
        (highest_high - prices_close).values,
        divisor.values,
        out=np.full(prices_close.shape, np.nan, dtype=float),
        where=divisor.values != 0,
    )

    percent_r = -(percent_r_raw) * 100
    return pd.Series(percent_r,index=prices_close.index)


def get_aroon_indicator(
    prices_high: pd.Series, prices_low: pd.Series, window: int = 25
) -> pd.DataFrame:
    """
    Calculate the Aroon Indicator for a given price series.

    Args:
        prices_high (pd.Series): Series of high prices.
        prices_low (pd.Series): Series of low prices.
        window (int): Number of periods for Aroon calculation (Default: 25).

    Returns:
        pd.DataFrame: Aroon Up and Aroon Down values.
    """
    # pos: vị trí của highest high trong cửa sổ (0..windown-1)
    pos = prices_high.rolling(window=window, min_period=window).apply(lambda x: x.argmax(), raw=True)
    neg_pos = prices_low.rolling(window=window, min_periods=window).apply(lambda x: x.argmin(), raw=True)
    # Aroon Up: Percentage of time since the highest high
    aroon_up = ((pos + 1) / window) * 100
    # Aroon Down: Percentage of time since the lowest low
    aroon_down = ((neg_pos + 1) / window) * 100

    arron_up=pd.Series(arron_up, index=prices_high.index, name= "Aroon Up")
    aroon_down=pd.Series(aroon_down, index=prices_high.index, name= "Aroon Down")

    return pd.concat([aroon_up, aroon_down], keys=["Aroon Up", "Aroon Down"], axis=1)


def get_commodity_channel_index(
    prices_high: pd.Series,
    prices_low: pd.Series,
    prices_close: pd.Series,
    window: int = 20,
    constant: float = 0.015,
) -> pd.Series:
    """
    Calculate the Commodity Channel Index (CCI) for a given price series.

    Args:
        prices_high (pd.Series): Series of high prices.
        prices_low (pd.Series): Series of low prices.
        prices_close (pd.Series): Series of closing prices.
        window (int): Number of periods for CCI calculation (Default: 20).
        constant (float): Constant multiplier for CCI (Default: 0.015).

    Returns:
        pd.Series: CCI values.
    """
    typical_prices = (prices_high + prices_low + prices_close) / 3
    sma_typical = typical_prices.rolling(window=window, min_periods=window).mean()

    # Tính Mean Deviation (Sai lệch trung bình tuyệt đối)
    mean_deviation = (typical_prices - sma_typical).abs().rolling(window=window,min_periods=window).mean()

    # --- Xử lý lỗi chia cho 0 ---
    divisor = constant * mean_deviation

    cci_arr = np.divide(
        (typical_prices - sma_typical).values,
        divisor.values,
        out=np.full(typical_prices.shape, np.nan, dtype=float),
        where=(divisor.values != 0),
    )

    return pd.Series(cci_arr, index=typical_prices.index, name="CCI")


# --- Sửa RVI về công thức chuẩn (không dùng Volume) ---
def get_relative_vigor_index(
    prices_open: pd.Series,
    prices_high: pd.Series,
    prices_low: pd.Series,
    prices_close: pd.Series,
    window: int = 10,
    smoothing: str = "sma",
) -> pd.Series:
    """
    Calculate the Relative Vigor Index (RVI) for a given price series (Standard Formula).

    Args:
        prices_open (pd.Series): Series of opening prices.
        prices_high (pd.Series): Series of high prices.
        prices_low (pd.Series): Series of low prices.
        prices_close (pd.Series): Series of closing prices.
        window (int): Number of periods for RVI smoothing (Default: 10).

    Returns:
        pd.Series: RVI values.
    """
    # Tử số (Numerator)
    numerator = prices_close - prices_open

    # Mẫu số (Denominator)
    denominator = prices_high - prices_low

    # Công thức RVI chuẩn: RVI = Smoothed(Numerator) / Smoothed(Denominator)
    # Smoothed_Numerator = EMA(Close - Open, window) (hoặc SMA/WMA)
    # Ở đây sử dụng SMA (Rolling Sum) để tính toán trung bình động đơn giản (Simple Moving Average)
    if smoothing == "sma":
        smoothed_numerator = numerator.rolling(window=window, min_periods=window).mean()
        smoothed_denominator = denominator.rolling(window=window, min_periods=window).mean()
    elif smoothing == "ema":
        smoothed_numerator = numerator.ewm(span=window, min_periods=window, adjust=False).mean()
        smoothed_denominator = denominator.ewm(span=window, min_periods=window, adjust=False).mean()
    else:
        raise ValueError("smoothing must be 'sma' or 'ema'.")

    # --- Xử lý lỗi chia cho 0 ---
    rvi_arr = np.divide(
        smoothed_numerator.values,
        smoothed_denominator.values,
        out=np.full(smoothed_numerator, np.nan, dtype=float),
        where=(smoothed_denominator.values != 0),
    )
    return pd.Series(rvi_arr, index=prices_close.index,name="RVI")

def get_force_index(
    prices_close: pd.Series, volumes: pd.Series, window: int = 13, min_periods: int = None
) -> pd.Series:
    """
    Calculate the Force Index (FI) for a given price series.

    The formula calculates Raw FI: FI = (Close_t - Close_{t-1}) * Volume_t,
    and then smooths it using an Exponential Moving Average (EMA).

    Args:
        prices_close (pd.Series): Series of closing prices.
        volumes (pd.Series): Series of trading volumes.
        window (int): Number of periods for Force Index EMA smoothing (Default: 13).

    Returns:
        pd.Series: Smoothed Force Index values.
    """
    if min_periods is None:
        min_periods = window

    raw_force_index = (prices_close.diff(1) * volumes).astype(float)

    smoothed_force_index = raw_force_index.ewm(span=window, min_periods=min_periods, adjust=False).mean()
    smoothed_force_index.name = "Force Index"
    return smoothed_force_index


# --- Sửa Ultimate Oscillator: Sửa công thức Buying Pressure ---
def get_ultimate_oscillator(
    prices_high: pd.Series,
    prices_low: pd.Series,
    prices_close: pd.Series,
    window_1: int = 7,
    window_2: int = 14,
    window_3: int = 28,
    scale: bool = True,
) -> pd.Series:
    """
    Calculate the Ultimate Oscillator for a given price series.

    Args:
        prices_high (pd.Series): Series of high prices.
        prices_low (pd.Series): Series of low prices.
        prices_close (pd.Series): Series of closing prices.
        window_1 (int): Number of periods for the first time period (Default: 7).
        window_2 (int): Number of periods for the second time period (Default: 14).
        window_3 (int): Number of periods for the third time period (Default: 28).

    Returns:
        pd.Series: Ultimate Oscillator values.
    """
    # 1. True Range (TR) - Phạm vi thực
    prev_close = prices_close.shift(1)
    tr_components = pd.concat(
        [
            prices_high - prices_low,
            (prices_high - prev_close).abs(),
            (prices_low - prev_close).abs(),
        ],
        axis=1,
    )
    true_range = tr_components.max(axis=1)

    # 2. Buying Pressure (BP): BP = Close_t - Min(Low_t, Close_{t-1}) áp lực mua
    buying_pressure = prices_close - pd.concat([prices_low, prev_close], axis=1).min(axis=1)
    # 3. Tính Total Buying Pressure (TBP) và Total True Range (TTR) = rolling sums
    tbp1 = buying_pressure.rolling(window=window_1, min_periods=window_1).sum()
    tbp2 = buying_pressure.rolling(window=window_2, min_periods=window_2).sum()
    tbp3 = buying_pressure.rolling(window=window_3, min_periods=window_3).sum()
    # Total True Range (TTR)
    ttr1 = true_range.rolling(window=window_1, min_periods=window_1).sum()
    ttr2 = true_range.rolling(window=window_2, min_periods=window_2).sum()
    ttr3 = true_range.rolling(window=window_3, min_periods=window_3).sum()
    # 4. Tính Average
    # Average 1 = TBP1 / TTR1 (Rolling Sum / Rolling Sum)
    avg_1 = tbp1.div(ttr1).where(ttr1 != 0)
    avg_2 = tbp2.div(ttr2).where(ttr2 != 0)
    avg_3 = tbp3.div(ttr3).where(ttr3 != 0)

    # 5. Ultimate Oscillator (Weighted Average)
    ultimate_oscillator = ((avg_1 * 4) + (avg_2 * 2) + avg_3) / 7.0
    if scale:
        ultimate_oscillator = ultimate_oscillator * 100.0

    ultimate_oscillator.name = " Ultimate Oscillator "
    return ultimate_oscillator

def get_percentage_price_oscillator(
    prices_close: pd.Series, short_window: int = 12, long_window: int = 26
) -> pd.Series:
    """
    Calculate the Percentage Price Oscillator (PPO) for a given price series.

    Args:
        prices_close (pd.Series): Series of closing prices.
        short_window (int): Number of periods for the short-term EMA (Default: 12).
        long_window (int): Number of periods for the long-term EMA (Default: 26).

    Returns:
        pd.Series: PPO values.
    """
    short_ema = prices_close.ewm(span=short_window, min_periods=short_window, adjust=False).mean()
    long_ema = prices_close.ewm(span=long_window, min_periods=long_window, adjust=False).mean()

    numerator = (short_ema - long_ema) * 100.0
    # safe divide, preserve index
    ppo_vals = numerator.div(long_ema) * 100.0
    ppo_vals.name = "PPO"
    return ppo_vals.astype(float)


def get_detrended_price_oscillator(
    prices_close: pd.Series,
    window: int = 20,
    moving_average_type: str = "sma",
) -> pd.Series:
    """
    Calculate the Detrended Price Oscillator (DPO) for a given price series.

    Args:
        prices_close (pd.Series): Series of closing prices.
        window (int): Number of periods for DPO calculation (Default: 20).

    Returns:
        pd.Series: DPO values.
    """
    shift_periods = int(window / 2) + 1

    if moving_average_type == "sma":
      # assume get_moving_average returns pd.Series of same index and uses min_periods=window
        moving_average = get_moving_average(prices_close, window)
    elif moving_average_type == "ema":
        moving_average = get_exponential_moving_average(prices_close, window)
    else:
        raise ValueError("Invalid moving average type. Choose either 'sma' or 'ema'.")

    # DPO = Close shifted (N/2 + 1) - MA shifted (N/2 + 1)
    # Phiên bản đơn giản hơn: DPO = Close_t - MA_{t - (N/2 + 1)}
    # Tuy nhiên, code ban đầu là: prices_close.shift(int(window / 2)) - moving_average.shift(int(window / 2))
    # Sửa theo công thức chuẩn: DPO = prices_close - moving_average.shift(shift_periods)
    dpo = prices_close - moving_average.shift(shift_periods)
    dpo.name = "DPO"
    return dpo

def get_average_directional_index(
    prices_high: pd.Series, prices_low: pd.Series, prices_close: pd.Series, window: int = 14
) -> pd.DataFrame:
    """
    Calculate the Average Directional Movement Index (ADX) and its components (+DI, -DI).

    Args:
        prices_high (pd.Series): Series of high prices.
        prices_low (pd.Series): Series of low prices.
        prices_close (pd.Series): Series of closing prices.
        window (int): Number of periods to consider for ADX calculation (Default: 14).

    Returns:
        pd.DataFrame: ADX, Plus Directional Indicator (+DI), and Minus Directional Indicator (-DI) values.
    """
    # 1. True Range (TR)
    prev_close = prices_close.shift(1)
    high_low = prices_high - prices_low
    high_close_prev = (prices_high - prev_close).abs()
    low_close_prev = (prices_low - prev_close).abs()
    tr = pd.concat([high_low, high_close_prev, low_close_prev], axis=1).max(axis=1)

    # 2. Directional Movement (DM)
    up_move = prices_high.diff()
    down_move = -prices_low.diff()
    plus_dm = up_move.where((up_move > down_move) & (up_move > 0), 0.0)
    minus_dm = down_move.where((down_move > up_move) & (down_move > 0), 0.0)

    # 3. Smoothed TR, +DM, -DM (dùng EMA cho ADX chuẩn)
    # Ở đây sử dụng EMA/Wilder's Smoothing (alpha = 1/window)
    def wilders_smoothing(series: pd.Series, window: int) -> pd.Series:
        return series.ewm(alpha=1.0/window, min_periods=window, adjust=True).mean()

    atr = wilders_smoothing(tr, window)
    smoothed_plus_dm = wilders_smoothing(plus_dm, window)
    smoothed_minus_dm = wilders_smoothing(minus_dm, window)

    # 4. Directional Index (DI)
    plus_di = (smoothed_plus_dm.div(atr)).where(atr !=0) * 100.0
    minus_di = (smoothed_minus_dm.div(atr)).where(atr !=0) * 100.0
    plus_di = plus_di.astype(float)
    minus_di = minus_di.astype(float)

    # 5. Directional Movement Index (DX)
    di_sum = plus_di + minus_di
    dx = ((plus_di - munus_di).abs().div(di_sum)).where (di_sum != 0) * 100.0
    # 6. Average Directional Movement Index (ADX) - Smoothing DX
    # ADX cũng được làm mượt bằng Wilder's Smoothing
    adx = wilders_smoothing(dx, window)
    adx = adx.astype (float)

    adx.name = "ADX"
    plus_di.name = "+DI"
    minus_di.name = "-DI"

    return pd.concat([adx, plus_di, minus_di], keys=["ADX", "+DI", "-DI"], axis=1)


def get_chande_momentum_oscillator(prices_close: pd.Series, window: int = 14) -> pd.Series:
    """
    Calculate the Chande Momentum Oscillator (CMO) for a given price series.

    Args:
        prices_close (pd.Series): Series of closing prices.
        window (int): Number of periods for CMO calculation (Default: 14).

    Returns:
        pd.Series: CMO values.
    """
    price_diff = prices_close.diff(1)

    # Tổng mức tăng thuần (Up Sum)
    up_sum = price_diff.where(price_diff > 0, 0.0).rolling(window=window, min_periods=window).sum()
    # Tổng mức giảm thuần (Down Sum)
    down_sum = (-price_dif.where(price_diff < 0, 0.0)).rolling(window=window, min_periods=window).sum()

    denom = up_sum + down_sum
    cmo = ((up_sum - down_sum).div(denom)).where(denom != 0) * 100.0
    cmo.name = "CMO"
    return cmo.astype(float)

    return cmo


def get_ichimoku_cloud(
    prices_high: pd.Series,
    prices_low: pd.Series,
    conversion_window: int = 9,
    base_window: int = 26,
    lead_span_b_window: int = 52,
) -> pd.DataFrame:
    """
    Ichimoku components:
    - Conversion Line (Tenkan-sen): (HighestHigh_N + LowestLow_N) / 2, N = conversion_window
    - Base Line (Kijun-sen): (HighestHigh_N + LowestLow_N) / 2, N = base_window
    - Leading Span A (Senkou Span A): (Conversion + Base) / 2 shifted forward by base_window
    - Leading Span B (Senkou Span B): (HighestHigh_N + LowestLow_N)/2 with N=lead_span_b_window then shifted forward by base_window
    Returns DataFrame with same index as inputs.
    """
    conversion_line = (
        prices_high.rolling(window=conversion_window, min_periods=conversion_window).max()
        + prices_low.rolling(window=conversion_window, min_periods=conversion_window).min()
    ) / 2.0
    conversion_line.name = "Conversion Line"

    base_line = (
        prices_high.rolling(window=base_window, min_periods=base_window).max()
        + prices_low.rolling(window=base_window, min_periods=base_window).min()
    ) / 2.0
    base_line.name = "Base Line"

    # Leading Span A: average of conversion and base, shifted forward by base_window
    lead_span_a = ((conversion_line + base_line) / 2.0).shift(base_window)
    lead_span_a.name = "Leading Span A"

    # Leading Span B: midpoint of highest high & lowest low over lead_span_b_window, shifted forward
    lead_span_b = (
        (
            prices_high.rolling(window=lead_span_b_window, min_periods=lead_span_b_window).max()
            + prices_low.rolling(window=lead_span_b_window, min_periods=lead_span_b_window).min()
        )
        / 2.0
    ).shift(base_window)
    lead_span_b.name = "Leading Span B"

    # (Optional) you could add Chikou/lagging span: prices_close.shift(-base_window)
    return pd.concat(
        [conversion_line, base_line, lead_span_a, lead_span_b],
        axis=1
    )


def get_stochastic_oscillator(
    prices_high: pd.Series,
    prices_low: pd.Series,
    prices_close: pd.Series,
    window: int = 14,
    smooth_window: int = 3,
) -> pd.DataFrame:
    """
    Stochastic %K and %D:
#     %K = (Close - LowestLow) / (HighestHigh - LowestLow) * 100
#     %D = SMA(%K, smooth_window)
    Returns DataFrame with Stochastic %K and %D.
    """
    lowest_low = prices_low.rolling(window=window, min_periods=window).min()
    highest_high = prices_high.rolling(window=window, min_periods=window).max()
    divisor = highest_high - lowest_low

    # use pandas division to preserve index and dtype
    raw_k = (prices_close - lowest_low).div(divisor).where(divisor != 0)
    stochastic_k = (raw_k * 100.0).rename("Stochastic %K")

    stochastic_d = stochastic_k.rolling(window=smooth_window, min_periods=smooth_window).mean().rename("Stochastic %D")

    return pd.concat([stochastic_k, stochastic_d], axis=1)

def get_moving_average_convergence_divergence(
    prices: pd.Series, short_window: int = 12, long_window: int = 26, signal_window: int = 9
) -> pd.DataFrame:
    """
    MACD Line = EMA(short) - EMA(long)
    Signal Line = EMA(MACD Line, signal_window)
    Histogram = MACD Line - Signal Line
    Returns DataFrame with columns ['MACD Line', 'Signal Line', 'Histogram'].
    """
    # Short/Long EMA
    short_ema = prices.ewm(span=short_window, min_periods=short_window, adjust=False).mean()
    long_ema = prices.ewm(span=long_window, min_periods=long_window, adjust=False).mean()

    # MACD Line
    macd_line = (short_ema - long_ema).rename("MACD Line")

    # Signal Line (EMA của MACD Line)
    signal_line = macd_line.ewm(span=signal_window, min_periods=signal_window, adjust=False).mean().rename("Signal Line")

    # Histogram
    histogram = macd_line - signal_line

    return pd.concat([macd_line, signal_line, histogram],axis=1)

def get_relative_strength_index(prices: pd.Series, window: int = 14) -> pd.Series:
    """
    Calculate RSI using Wilder's smoothing (EMA with com=window-1).
    Returns pd.Series (float) indexed like `prices`.
    """
    price_diff = prices.diff(1)

    # Upward and downward price changes
    up_changes = price_diff.where(price_diff > 0, 0.0)
    down_changes = (-price_diff).where(price_diff < 0, 0.0)

    avg_gain = up_changes.ewm(com=window - 1, adjust=False, min_periods=window).mean()
    avg_loss = down_changes.ewm(com=window - 1, adjust=False, min_periods=window).mean()

    # Relative Strength (RS): handle divide-by-zero by setting RS = +inf where avg_loss == 0
    # Use pandas operations to preserve index
    rs = avg_gain.div(avg_loss).where(avg_loss != 0, np.inf)

    # 5) RSI
    rsi = 100.0 - (100.0 / (1.0 + rs))

    rsi.name = "RSI"
    return rsi.astype(float)

def get_balance_of_power(
    prices_open: pd.Series,
    prices_high: pd.Series,
    prices_low: pd.Series,
    prices_close: pd.Series,
) -> pd.Series:
    """
    Balance of Power (BOP) = (Close - Open) / (High - Low).
    If High == Low, returns 0 for that period.
    Returns pd.Series (float) indexed like inputs.
    """
    numerator = prices_close - prices_open
    divisor = prices_high - prices_low

    # Use pandas division and where to preserve index and handle divide-by-zero
    bop = numerator.div(divisor).where(divisor != 0, 0.0)

    bop.name = "BOP"
    return bop.astype(float)